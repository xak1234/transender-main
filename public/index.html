<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hellspin 666 V4 Pusher Combo Mode</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <!-- TEMPORARY Firebase Configuration - REMOVE AFTER SETTING ENV VARS -->
    <script src="firebase-config-temp.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            touch-action: none !important;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* Removed any potential spacing */
        }

        /* Mobile background image */
        @media (max-width: 768px) {
            body {
                background: url('tranback.jpg') center center/cover no-repeat fixed;
            }
        }

        canvas {
            display: block;
            margin: 0; /* Removed auto margins to maximize space */
            background: transparent;
            border-radius: 5px; /* Reduced border radius */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3); /* Reduced shadow */
            touch-action: none !important;
            user-select: none;
            -webkit-user-select: none;
            /* Anti-flicker optimizations */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            will-change: auto;
            position: relative;
            z-index: 1;
        }

        /* Tablet-specific styling (768px and below, but larger than 480px) */
        @media (min-width: 481px) and (max-width: 768px) {
            body, html {
                margin: 0;
                padding: 0;
                height: 100vh;
                overflow: hidden;
            }

            canvas {
                width: 95vw;
                height: 85vh;
                max-width: 95vw;
                max-height: 85vh;
                border-radius: 8px;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
                display: block;
                margin: 0 auto;
                margin-top: 15px; /* More space for top player display */
            }
        }

        /* Mobile canvas positioning (480px and below) */
        @media (max-width: 480px) {
            body, html {
                margin: 0;
                padding: 0;
                height: 100vh;
                overflow: hidden;
            }

            canvas {
                width: 98vw;
                height: 75vh;
                max-width: 98vw;
                max-height: 75vh;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
                display: block;
                margin: 0 auto;
                margin-top: 20px; /* Reduced space for top player display */
            }
        }

        @media (max-width: 480px) {
            canvas {
                margin-top: 15px; /* Reduced space on smaller screens */
            }
        }

        /* Performance optimizations for tablets */
        @media (min-width: 481px) and (max-width: 1024px) {
            /* Reduce visual effects for better performance */
            canvas {
                /* Disable hardware acceleration issues on some tablets */
                -webkit-transform: translateZ(0);
                transform: translateZ(0);
                /* Reduce shadow complexity */
                box-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
            }
            
            /* Optimize for Fire tablet specifically */
            @supports (-webkit-appearance: none) {
                canvas {
                    /* Fire tablet specific optimizations */
                    -webkit-backface-visibility: hidden;
                    backface-visibility: hidden;
                    -webkit-perspective: 1000;
                    perspective: 1000;
                }
            }
        }

        #splashScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
        }

        .splash-content {
            text-align: center;
            max-width: 90%;
            max-height: 90%;
        }

        .splash-image {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .splash-text {
            margin-top: 30px;
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            animation: pulse 2s ease-in-out infinite;
        }

        /* Tablet-specific styling for splash screen */
        @media (min-width: 481px) and (max-width: 768px) {
            .splash-image {
                max-height: 80vh;
                border-radius: 15px;
                box-shadow: 0 0 40px rgba(255, 255, 255, 0.4);
            }

            .splash-text {
                margin-top: 40px;
                font-size: 28px;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #introScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('transendback.jpg') center 20%/cover no-repeat;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
        }

        #introScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            animation: glow 2s ease-in-out infinite alternate;
        }

        #introScreen h2 {
            font-size: 24px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
        }

        /* Tablet-specific styling for intro screen */
        @media (min-width: 481px) and (max-width: 768px) {
            #introScreen h1 {
                font-size: 56px;
                margin-bottom: 25px;
            }

            #introScreen h2 {
                font-size: 28px;
                margin-bottom: 35px;
            }
        }

        #leaderboardContainer {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin: 20px;
            max-width: 400px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 204, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        }

        #leaderboardContainer h3 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #00ffcc;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.8);
        }

        /* Tablet-specific styling for leaderboard container */
        @media (min-width: 481px) and (max-width: 768px) {
            #leaderboardContainer {
                padding: 25px;
                margin: 25px;
                max-width: 500px;
                border-radius: 12px;
            }

            #leaderboardContainer h3 {
                font-size: 28px;
                margin-bottom: 20px;
            }
        }

        #introTopPlayerContainer {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 10px 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            z-index: 1001;
            text-align: center;
            min-width: 250px;
            max-width: 400px;
            white-space: nowrap;
            overflow: hidden;
        }



        #introTopPlayerDisplay {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: #fff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            flex-wrap: nowrap;
            line-height: 1;
            margin: 0;
        }

        #introTopPlayerName {
            font-weight: bold;
            color: #ffd700;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }

        #introTopPlayerScore {
            font-weight: bold;
            color: #00ffcc;
            white-space: nowrap;
            margin-left: 10px;
        }

        #gameInstructions {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            backdrop-filter: blur(5px);
        }

        #gameInstructions h4 {
            font-size: 16px;
            color: #ffd700;
            margin: 0 0 10px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            animation: glow 2s ease-in-out infinite alternate;
        }

        #gameInstructions p {
            font-size: 12px;
            color: #ffd700;
            margin: 5px 0;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        /* Tablet-specific styling for game instructions */
        @media (min-width: 481px) and (max-width: 768px) {
            #gameInstructions {
                bottom: 120px;
                padding: 20px;
                border-radius: 10px;
                max-width: 500px;
            }

            #gameInstructions h4 {
                font-size: 20px;
                margin: 0 0 15px 0;
            }

            #gameInstructions p {
                font-size: 16px;
                margin: 8px 0;
            }
        }

        #pressAnyKeyPrompt {
            position: absolute !important;
            top: 60% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            text-align: center;
            animation: pulse 2s infinite;
            z-index: 1001;
            width: auto;
            max-width: 400px;
            margin: 0 !important;
            padding: 0;
            box-sizing: border-box;
        }

        /* Tablet-specific styling for press any key prompt */
        @media (min-width: 481px) and (max-width: 768px) {
            #pressAnyKeyPrompt {
                font-size: 28px;
                max-width: 500px;
            }
        }



        #leaderboardList {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #leaderboardList li {
            font-size: 18px;
            margin: 8px 0;
            padding: 8px 12px;
            background: rgba(0, 255, 204, 0.1);
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 204, 0.2);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        #instructionsContainer {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin: 20px;
            max-width: 400px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #instructionsContainer h4 {
            font-size: 10px;
            margin-bottom: 8px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            font-family: 'Orbitron', sans-serif;
            text-align: center;
        }

        #instructionsContainer p {
            font-size: 7px;
            margin: 4px 0;
            padding: 3px 0;
            color: #fff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            line-height: 1.2;
        }

        #startButton {
            background: linear-gradient(45deg, #ff4500, #ff6347);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }

        #startButton:hover {
            background: linear-gradient(45deg, #ff6347, #ff4500);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.8);
        }

        @keyframes glow {
            0% { text-shadow: 0 0 15px rgba(255, 255, 255, 0.6); }
            50% { text-shadow: 0 0 25px rgba(255, 255, 255, 0.8); }
            100% { text-shadow: 0 0 15px rgba(255, 255, 255, 0.6); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #starCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        #scoreBoard {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 20px;
            flex-wrap: nowrap;
            white-space: nowrap;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #fff;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 12px;
            border-radius: 8px;
            z-index: 1001;
        }

        @keyframes flashRed {
            0%, 100% { color: #ff0000; }
            50% { color: #ffffff; }
        }

        .low-balls {
            animation: flashRed 1s step-start infinite;
        }

        @media (max-width: 480px) {
            #scoreBoard {
                font-size: 14px;
                gap: 10px;
                padding: 4px 8px;
                top: 60px;
            }
        }

        #gameOverScreen {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
            display: none;
            width: 80%;
            max-width: 600px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 204, 0.3);
            z-index: 2000;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg); 
                box-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
            }
            25% { 
                transform: translateY(-5px) rotate(0.5deg); 
                box-shadow: 0 0 40px rgba(0, 255, 204, 1);
            }
            50% { 
                transform: translateY(-10px) rotate(0deg); 
                box-shadow: 0 0 50px rgba(0, 255, 204, 0.9);
            }
            75% { 
                transform: translateY(-5px) rotate(-0.5deg); 
                box-shadow: 0 0 40px rgba(0, 255, 204, 1);
            }
        }
        #gameOverScreen h1 { font-size: 36px; margin-bottom: 20px; }
        #gameOverScreen h2 { font-size: 28px; margin-bottom: 20px; }
        #gameOverScreen ul { 
            list-style: none; 
            padding: 0; 
            margin-bottom: 20px; 
            text-align: left;
            font-family: 'Courier New', monospace;
        }
        #gameOverScreen li { 
            font-size: 18px; 
            margin: 8px 0; 
            padding: 5px 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            white-space: normal;
            overflow: visible;
            line-height: 1.4;
        }
        #nameInputSection {
            margin-bottom: 20px;
        }
        
        #gameOverScreen input {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            padding: 8px;
            margin-bottom: 20px;
            border-radius: 5px;
            border: none;
        }
        
        #usernameInput {
            width: 200px;
        }
        
        #countryInput {
            width: 80px;
            margin-left: 10px;
        }
        #restartButton {
            background: #ff4500;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #restartButton:hover { background: #cc3700; }

        #gameTopPlayerDisplay {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 10px 20px;
            color: #ffd700;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            display: none;
            backdrop-filter: blur(10px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Tablet-specific styling for top player display */
        @media (min-width: 481px) and (max-width: 768px) {
            #gameTopPlayerDisplay {
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 18px;
                padding: 12px 25px;
                border-radius: 10px;
                width: auto;
                max-width: 600px;
                box-sizing: border-box;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            #introTopPlayerContainer {
                min-width: 300px;
                max-width: 600px;
                padding: 15px 25px;
            }
            
            #introTopPlayerDisplay {
                font-size: 16px;
            }
            
            /* Tablet-specific styling for control icons */
            #controlIcons {
                bottom: 20px;
                left: 20px;
                gap: 15px;
            }
            
            .control-icon {
                width: 50px;
                height: 50px;
                font-size: 24px;
                margin-right: 0;
            }
            
            /* Tablet-specific styling for leaderboard names at top */
            #introTopPlayerDisplay span {
                font-size: 14px;
            }
            
            #introTopPlayerName,
            #introTopPlayerScore,
            #introWorstPlayerName,
            #introWorstPlayerScore {
                font-size: 14px;
            }
        }

        /* Mobile-specific styling for top player display */
        @media (max-width: 480px) {
            #gameTopPlayerDisplay {
                top: 5px;
                left: 10px;
                right: 10px;
                transform: none;
                font-size: 16px;
                padding: 8px 15px;
                border-radius: 8px;
                width: auto;
                max-width: calc(100vw - 20px);
                box-sizing: border-box;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            #introTopPlayerContainer {
                min-width: 200px;
                max-width: calc(100vw - 40px);
                padding: 10px 15px;
            }
            
            #introTopPlayerDisplay {
                font-size: 14px;
            }
            
            /* Mobile-specific styling for control icons */
            #controlIcons {
                bottom: 10px;
                left: 10px;
                gap: 5px;
            }
            
            .control-icon {
                width: 20px;
                height: 20px;
                font-size: 10px;
                margin-right: 0;
            }
            
            /* Mobile-specific styling for Franksgames footer */
            .footer-text {
                font-size: 6px;
                padding: 3px 8px;
                bottom: 5px;
            }
            
            /* Mobile-specific styling for leaderboard names at top */
            #introTopPlayerDisplay span {
                font-size: 10px;
            }
            
            #introTopPlayerName,
            #introTopPlayerScore,
            #introWorstPlayerName,
            #introWorstPlayerScore {
                font-size: 10px;
            }
            
            /* Mobile-specific styling for game over screen */
            #gameOverScreen {
                width: 95%;
                max-width: 400px;
                padding: 20px;
                margin: 10px;
            }
            
            #gameOverScreen h1 {
                font-size: 28px;
                margin-bottom: 15px;
            }
            
            #gameOverScreen h2 {
                font-size: 22px;
                margin-bottom: 15px;
            }
            
            #gameOverScreen li {
                font-size: 14px;
                margin: 6px 0;
                padding: 4px 8px;
                line-height: 1.3;
            }
            
            #gameOverScreen input {
                font-size: 16px;
                padding: 6px;
                margin-bottom: 15px;
            }
            
            #usernameInput {
                width: 180px;
            }
            
            #restartButton {
                font-size: 18px;
                padding: 8px 16px;
                margin-top: 10px;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            #gameTopPlayerDisplay {
                top: 2px;
                left: 5px;
                right: 5px;
                font-size: 14px;
                padding: 6px 12px;
                border-radius: 6px;
                max-width: calc(100vw - 10px);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            #gameInstructions {
                bottom: 60px;
                padding: 12px;
                max-width: 90%;
            }
            
            #gameInstructions h4 {
                font-size: 16px;
            }
            
            #gameInstructions p {
                font-size: 12px;
            }
            
            #pressAnyKeyPrompt {
                top: 50%;
                font-size: 20px;
            }
            
            /* Extra small mobile game over screen */
            #gameOverScreen {
                width: 98%;
                max-width: 350px;
                padding: 15px;
                margin: 5px;
            }
            
            #gameOverScreen h1 {
                font-size: 24px;
                margin-bottom: 10px;
            }
            
            #gameOverScreen h2 {
                font-size: 18px;
                margin-bottom: 10px;
            }
            
            #gameOverScreen li {
                font-size: 12px;
                margin: 4px 0;
                padding: 3px 6px;
                line-height: 1.2;
            }
            
            #gameOverScreen ul {
                margin-bottom: 15px;
                max-height: 200px;
                overflow-y: auto;
            }
            
            #restartButton {
                font-size: 16px;
                padding: 10px 20px;
                margin-top: 15px;
                min-height: 44px; /* Ensure touch target is large enough */
            }
        }

        /* Very small mobile devices */
        @media (max-width: 360px) {
            #gameOverScreen {
                width: 100%;
                max-width: 320px;
                padding: 10px;
                margin: 2px;
            }
            
            #gameOverScreen h1 {
                font-size: 20px;
                margin-bottom: 8px;
            }
            
            #gameOverScreen h2 {
                font-size: 16px;
                margin-bottom: 8px;
            }
            
            #gameOverScreen li {
                font-size: 11px;
                margin: 3px 0;
                padding: 2px 4px;
                line-height: 1.1;
            }
            
            #gameOverScreen ul {
                max-height: 150px;
                margin-bottom: 10px;
            }
            
            #restartButton {
                font-size: 14px;
                padding: 12px 24px;
                margin-top: 20px;
                min-height: 48px;
            }
        }

        #gameTopPlayerDisplay .trophy {
            font-size: 20px;
            margin-right: 8px;
        }

        /* Control Icons */
        #controlIcons {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        .control-icon {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }

        .control-icon:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }

        .control-icon.active {
            background: rgba(0, 255, 204, 0.3);
            border-color: #00ffcc;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.6);
        }

        .control-icon i {
            font-size: 24px;
            color: #fff;
        }

        /* Tablet responsive for control icons */
        @media (min-width: 481px) and (max-width: 768px) {
            #controlIcons {
                bottom: 20px;
                left: 20px;
                gap: 15px;
            }

            .control-icon {
                width: 55px;
                height: 55px;
            }

            .control-icon i {
                font-size: 26px;
            }
        }

        /* Mobile responsive for control icons */
        @media (max-width: 480px) {
            #controlIcons {
                bottom: 10px;
                left: 10px;
                gap: 10px;
            }

            .control-icon {
                width: 40px;
                height: 40px;
            }

            .control-icon i {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <!-- Top player display above game window -->
    <div id="gameTopPlayerDisplay">
        <span id="gameTopPlayerText">Loading...</span>
    </div>

    <div id="splashScreen">
        <div class="splash-content">
            <img src="trans.jpg" alt="TransEnder" class="splash-image">
        </div>
    </div>
    
    <div id="introScreen">
        <!-- Top player display at the top -->
        <div id="introTopPlayerContainer">
            <div id="introTopPlayerDisplay">
                <span style="color: #ffd700; margin-right: 8px;">#1 ❤️</span>
                <span id="introTopPlayerName">Loading...</span>
                <span style="margin: 0 10px; color: #fff;">-</span>
                <span id="introTopPlayerScore">-</span>
                <span style="margin: 0 10px; color: #fff;">|</span>
                <span style="color: #00ff00; margin-right: 8px;">Worst Player:</span>
                <span id="introWorstPlayerName">Loading...</span>
                <span style="margin: 0 10px; color: #fff;">-</span>
                <span id="introWorstPlayerScore">-</span>
            </div>
        </div>
        
        <!-- Game Instructions -->
        <div id="gameInstructions">
            <h4>Guide your balls to the Yellow Win Zones</h4>
            <p>Use Parachutes and Turbo to move</p>
            <p>Use Parachutes and Magnetic Power!</p>
            <p>Then using the Super Magnet, powerups</p>
            <p>Control the moving panels for extra points</p>
            <p>Become Number 1</p>
        </div>
        
        <!-- Press any key prompt in the center -->
    <div id="pressAnyKeyPrompt">
    </div>


    </div>

    <div id="scoreBoard">
        <span id="scoreDisplay">Score: 0</span>
        <span id="ballsLeftDisplay">Balls Left: 0</span>
        <span id="lostBallsDisplay">Lost Balls: 0</span>
    </div>
    <canvas id="starCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Control Icons -->
    <div id="controlIcons">
        <div class="control-icon" id="exitIcon" title="Game Reset">
            <i class="fas fa-home"></i>
        </div>
        <div class="control-icon" id="musicIcon" title="Toggle Music">
            <i class="fas fa-music"></i>
            <span id="musicTrackIndicator" style="position: absolute; top: -5px; right: -5px; background: #00ffcc; color: #000; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: bold; display: none;">1</span>
        </div>
        <div class="control-icon" id="pauseIcon" title="Pause Game">
            <i class="fas fa-pause"></i>
        </div>
        <div class="control-icon" id="scoresIcon" title="Score Instructions">
            <i class="fas fa-info-circle"></i>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <h1>Game Over</h1>
        <div id="nameInputSection">
            <input id="usernameInput" type="text" placeholder="Enter your name" maxlength="20">
        </div>
        <h2>Global Champions & Losers</h2>
        <ul id="globalHighScoreList"></ul>
        <button id="restartButton">Restart</button>
    </div>
    <script>
        console.log('Script started - Version 2.0');
        // Cache busting - force reload of updated JavaScript
        
        // Firebase configuration - will be populated by server or use fallback
        console.log('🔍 Client-side Firebase config check:');
        console.log('FIREBASE_API_KEY:', window.FIREBASE_API_KEY ? 'SET' : 'MISSING');
        console.log('FIREBASE_PROJECT_ID:', window.FIREBASE_PROJECT_ID ? 'SET' : 'MISSING');
        console.log('FIREBASE_AUTH_DOMAIN:', window.FIREBASE_AUTH_DOMAIN ? 'SET' : 'MISSING');
        
        // Use server-injected config if available, otherwise use temporary fallback
        var firebaseConfig = window.FIREBASE_API_KEY ? {
            apiKey: window.FIREBASE_API_KEY || "",
            authDomain: window.FIREBASE_AUTH_DOMAIN || "",
            projectId: window.FIREBASE_PROJECT_ID || "",
            storageBucket: window.FIREBASE_STORAGE_BUCKET || "",
            messagingSenderId: window.FIREBASE_MESSAGING_SENDER_ID || "",
            appId: window.FIREBASE_APP_ID || "",
            measurementId: window.FIREBASE_MEASUREMENT_ID || ""
        } : (window.firebaseConfig || {
            apiKey: "",
            authDomain: "",
            projectId: "",
            storageBucket: "",
            messagingSenderId: "",
            appId: "",
            measurementId: ""
        });
        
        console.log('🔍 Firebase config object:', firebaseConfig);
        
        // Declare db variable globally
        var db = null;
        
        // Check if Firebase config is complete
        const requiredClientVars = ['FIREBASE_API_KEY', 'FIREBASE_PROJECT_ID', 'FIREBASE_AUTH_DOMAIN'];
        const missingClientVars = requiredClientVars.filter(varName => !window[varName]);
        
        if (missingClientVars.length > 0) {
            console.error('❌ Client-side Firebase config incomplete. Missing:', missingClientVars.join(', '));
            console.log('📋 Please set the following environment variables:');
            console.log('   FIREBASE_API_KEY, FIREBASE_PROJECT_ID, FIREBASE_AUTH_DOMAIN');
            console.log('📖 See FIREBASE_SETUP.md for detailed instructions');
            // Don't initialize Firebase if config is incomplete
            db = null;
        } else {
            // Initialize Firebase
            try {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                
                // Enable offline persistence and retry logic
                db.enablePersistence({synchronizeTabs: true})
                    .then(() => {
                        console.log('✅ Firebase initialized for client-side leaderboard');
                        console.log('📊 Project ID:', window.FIREBASE_PROJECT_ID);
                        console.log('💾 Offline persistence enabled');
                    })
                    .catch((err) => {
                        if (err.code == 'failed-precondition') {
                            console.warn('⚠️ Multiple tabs open, persistence can only be enabled in one tab at a time');
                        } else if (err.code == 'unimplemented') {
                            console.warn('⚠️ Browser doesn\'t support persistence');
                        }
                        console.log('✅ Firebase initialized for client-side leaderboard');
                        console.log('📊 Project ID:', window.FIREBASE_PROJECT_ID);
                    });
                    
                // Add connection state listener
                db.enableNetwork().then(() => {
                    console.log('🌐 Firebase network connection enabled');
                }).catch((error) => {
                    console.error('❌ Firebase network connection failed:', error);
                });
                
                // Monitor connection state
                db.enableNetwork().then(() => {
                    // Log connection attempts
                    console.log('🔍 Monitoring Firebase connection state...');
                    
                    // Test the connection with a simple query
                    setTimeout(async () => {
                        try {
                            const testSnapshot = await db.collection('leaderboard').limit(1).get();
                            console.log('✅ Firebase connection test successful');
                        } catch (error) {
                            console.error('❌ Firebase connection test failed:', error);
                        }
                    }, 2000);
                    
                    // Additional connection test with timeout
                    setTimeout(async () => {
                        try {
                            const testPromise = db.collection('leaderboard').limit(1).get();
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Firebase connection timeout')), 5000)
                            );
                            await Promise.race([testPromise, timeoutPromise]);
                            console.log('✅ Firebase connection test with timeout successful');
                        } catch (error) {
                            console.error('❌ Firebase connection test with timeout failed:', error);
                        }
                    }, 5000);
                });
                
            } catch (error) {
                console.error('❌ Client-side Firebase initialization failed:', error.message);
                db = null;
            }
        }



        const starCanvas = document.getElementById('starCanvas');
        const starCtx = starCanvas.getContext('2d');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        if (!canvas || !ctx) {
            console.error('Canvas or context not found');
            alert('Failed to initialize game canvas. Please check your browser.');
            throw new Error('Canvas initialization failed');
        }
        console.log('Canvas initialized');

        // Splash screen elements
        const splashScreen = document.getElementById('splashScreen');
        
        // Intro screen elements
        const introScreen = document.getElementById('introScreen');
        const leaderboardList = document.getElementById('leaderboardList');
        const startButton = document.getElementById('startButton');

        // Verify single canvas element
        const canvases = document.querySelectorAll('#gameCanvas, #starCanvas');
        if (canvases.length < 2) {
            console.warn('Expected two canvas elements for starfield and game');
        }

        const gameOverScreen = document.getElementById('gameOverScreen');
        const highScoreList = document.getElementById('highScoreList');
        const globalHighScoreList = document.getElementById('globalHighScoreList');
        const restartButton = document.getElementById('restartButton');
        const usernameInput = document.getElementById('usernameInput');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const ballsLeftDisplay = document.getElementById('ballsLeftDisplay');
        const lostBallsDisplay = document.getElementById('lostBallsDisplay');
        const scoreBoard = document.getElementById('scoreBoard');
        
        // Performance detection and optimization
        const isTablet = window.innerWidth >= 481 && window.innerWidth <= 1024;
        const isFireTablet = navigator.userAgent.includes('Silk') || navigator.userAgent.includes('Fire');
        const isLowPerformance = isTablet || isFireTablet;
        
        // Performance settings based on device
        const PERFORMANCE_SETTINGS = {
            maxParticles: isLowPerformance ? 50 : 200,
            particleLifetime: isLowPerformance ? 20 : 30,
            backgroundGridDensity: isLowPerformance ? 100 : 50,
            enableShadows: !isLowPerformance,
            enableComplexEffects: !isLowPerformance,
            frameRate: isLowPerformance ? 30 : 60
        };
        
        console.log('Performance settings:', PERFORMANCE_SETTINGS);
        console.log('Device type:', isTablet ? 'Tablet' : 'Desktop', isFireTablet ? '(Fire Tablet)' : '');
        
        // Game state variables - declared early to avoid initialization errors
        let lastTapTime = 0;
        let ufo = null;
        let ufoSpawnTimer = 0;
        let lastScoreMilestone = 0;
        let bonusFlashTime = 0;
        let parachuteFlashTime = 0;
        let lostBalls = 0;
        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let coinCount = 100;
        let consecutiveWins = 0;
        let magnetActive = false;
        let magnetTimer = 0;
        let resizeTimer = 0;
        let resizeInterval = Math.floor(Math.random() * (216 - 108 + 1)) + 108;
        let multiplierTimer = 0;
        let coinMagnetTimer = 0;
        let superParachuteTimer = 0;
        let lastTapX = 0;
        let lastTapY = 0;
        let tapActive = false;
        let lastFrameTime = 0;
        const starCount = 150;
        let stars = [];
        
        // Win zone drag tracking
        let draggedZone = null;
        let dragStartY = 0;
        let dragStartZoneY = 0;
        let coins = [];
        let particles = [];
        let obstacles = [];
        let powerUps = [];
        
        // Top player display variables
        let topPlayerName = 'Loading...';
        let topPlayerScore = 0;
        let worstPlayerName = 'Loading...';
        let worstPlayerScore = 0;
        
        // Control icons and music variables
        let musicAudio = null;
        let musicPlaying = false;
        let gamePaused = false;
        let currentMusicIndex = 0;
        let musicPlaylist = ['oxy.mp3', 'ard.mp3', 'bag.mp3', 'fonker.mp3', 'anub.mp3', '4m.mp3'];
        const exitIcon = document.getElementById('exitIcon');
        const musicIcon = document.getElementById('musicIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const scoresIcon = document.getElementById('scoresIcon');
        
        // Auto-fire system variables
        let lastFireTime = 0;
        let autoFireTimer = 0;
        let autoFireInterval = 30000; // 30 seconds in milliseconds
        let autoFireBallCount = 50;
        
        // Ball killer demon variables
        let ballKiller = null;
        let ballKillerSpawnTimer = 0;
        let ballKillerSpawnInterval = 2100000; // 35 minutes in milliseconds (35 * 60 * 1000)
        let ballKillerActive = false;
        
        // Blue bomb variables
        let blueBombs = [];
        let blueBombSpawnTimer = 0;
        let blueBombSpawnInterval = 10000; // 10 seconds in milliseconds (reduced for testing)
        let maxBlueBombs = 3; // Allow up to 3 bombs at once
        
        // Rocket variables
        let rocket = null;
        let rocketLanded = false;
        
        // Game objects - declared early to avoid initialization errors
        const pusher = { x: 250, y: 100, width: 300, height: 50, speed: 4, direction: 1 };
        const edgeY = 500;
        const bottomWinZone = { 
            x: 350, 
            width: 100, 
            speed: 1.1, 
            direction: 1, 
            glowTime: 0,
            hitCount: 0,
            lastHitTime: 0,
            fatTime: 0,
            baseWidth: 100,
            hitThreshold: 5, // Change direction after 5 hits
            directionChangeCooldown: 0, // Prevent rapid direction changes
            repelMode: false, // Repel balls down instead of winning
            repelTimer: 0, // Timer for repel mode (20 seconds = 1200 frames at 60fps)
            repelCooldown: 0, // Cooldown before next repel mode can activate
            isDragging: false,
            playerControlled: false,
            originalSpeed: 1.1
        };
        const leftWinZone = { 
            x: 50, 
            y: 300, 
            width: 50, 
            height: 100, 
            speed: 2.475, 
            direction: 1, 
            glowTime: 0,
            hitCount: 0,
            lastHitTime: 0,
            fatTime: 0,
            baseWidth: 50,
            hitThreshold: 3, // Change direction after 3 hits (faster than bottom)
            directionChangeCooldown: 0, // Prevent rapid direction changes
            repelMode: false, // Repel balls down instead of winning
            repelTimer: 0, // Timer for repel mode (20 seconds = 1200 frames at 60fps)
            repelCooldown: 0, // Cooldown before next repel mode can activate
            isDragging: false,
            playerControlled: false,
            originalSpeed: 2.475
        };
        const rightWinZone = { 
            x: 700, 
            y: 300, 
            width: 50, 
            height: 100, 
            speed: 2.475, 
            direction: -1, 
            glowTime: 0,
            hitCount: 0,
            lastHitTime: 0,
            fatTime: 0,
            baseWidth: 50,
            hitThreshold: 3, // Change direction after 3 hits (faster than bottom)
            directionChangeCooldown: 0, // Prevent rapid direction changes
            repelMode: false, // Repel balls down instead of winning
            repelTimer: 0, // Timer for repel mode (20 seconds = 1200 frames at 60fps)
            repelCooldown: 0, // Cooldown before next repel mode can activate
            isDragging: false,
            playerControlled: false,
            originalSpeed: 2.475
        };

        // Load and display top player on intro screen
        async function loadTopPlayer() {
            try {
                // Check if Firebase is initialized, retry if not
                if (!db) {
                    console.warn('⚠️ Firebase not initialized, retrying in 1 second...');
                    // Set loading state
                    const introTopPlayerName = document.getElementById('introTopPlayerName');
                    const introTopPlayerScore = document.getElementById('introTopPlayerScore');
                    if (introTopPlayerName) introTopPlayerName.textContent = 'Loading...';
                    if (introTopPlayerScore) introTopPlayerScore.textContent = '...';
                    
                    const introWorstPlayerName = document.getElementById('introWorstPlayerName');
                    const introWorstPlayerScore = document.getElementById('introWorstPlayerScore');
                    if (introWorstPlayerName) introWorstPlayerName.textContent = 'Loading...';
                    if (introWorstPlayerScore) introWorstPlayerScore.textContent = '...';
                    
                    // Retry after 1 second
                    setTimeout(loadTopPlayer, 1000);
                    return;
                }
                
                console.log('Loading top player from Firebase');
                const snapshot = await db.collection('leaderboard')
                    .orderBy('score', 'desc')
                    .limit(10)
                    .get();
                
                const scores = [];
                snapshot.forEach(doc => {
                    scores.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                
                console.log('Loaded scores from Firebase:', scores);
                
                if (scores.length === 0) {
                    // Update intro display
                    const introTopPlayerName = document.getElementById('introTopPlayerName');
                    const introTopPlayerScore = document.getElementById('introTopPlayerScore');
                    if (introTopPlayerName) introTopPlayerName.textContent = 'No scores yet';
                    if (introTopPlayerScore) introTopPlayerScore.textContent = '-';
                    // Update worst player display
                    const introWorstPlayerName = document.getElementById('introWorstPlayerName');
                    const introWorstPlayerScore = document.getElementById('introWorstPlayerScore');
                    if (introWorstPlayerName) introWorstPlayerName.textContent = 'No scores yet';
                    if (introWorstPlayerScore) introWorstPlayerScore.textContent = '-';
                    // Update game display variables
                    window.topPlayerName = 'No scores yet';
                    window.topPlayerScore = 0;
                    window.worstPlayerName = 'No scores yet';
                    window.worstPlayerScore = 0;
                    // Update game display
                    const gameTopPlayerText = document.getElementById('gameTopPlayerText');
                    if (gameTopPlayerText) {
                        gameTopPlayerText.textContent = 'No scores yet - Be the first!';
                    }
                } else {
                    const topPlayer = scores[0]; // Get the first (highest) score
                    const worstPlayer = scores[scores.length - 1]; // Get the last (lowest) score
                    
                    // Update intro display
                    const introTopPlayerName = document.getElementById('introTopPlayerName');
                    const introTopPlayerScore = document.getElementById('introTopPlayerScore');

                    if (introTopPlayerName) introTopPlayerName.textContent = topPlayer.username;
                    if (introTopPlayerScore) introTopPlayerScore.textContent = topPlayer.score;
                    
                    // Update worst player display - show rank 8 player (biggest loser)
                    const introWorstPlayerName = document.getElementById('introWorstPlayerName');
                    const introWorstPlayerScore = document.getElementById('introWorstPlayerScore');
                    const rank8Player = scores.length >= 8 ? scores[7] : scores[scores.length - 1]; // Player at rank 8 (index 7)

                    if (introWorstPlayerName) introWorstPlayerName.textContent = rank8Player.username;
                    if (introWorstPlayerScore) introWorstPlayerScore.textContent = rank8Player.score;
                    
                    // Update game display variables
                    window.topPlayerName = topPlayer.username;
                    window.topPlayerScore = topPlayer.score;
                    window.worstPlayerName = rank8Player.username;
                    window.worstPlayerScore = rank8Player.score;
                    
                    // Update game display - show rank 1 and rank 8 players (biggest loser)
                    const gameTopPlayerText = document.getElementById('gameTopPlayerText');
                    if (gameTopPlayerText) {
                        const rank8Player = scores.length >= 8 ? scores[7] : scores[scores.length - 1]; // Player at rank 8 (index 7)

                        gameTopPlayerText.innerHTML = `<span style="color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);">#1 Champion: ${topPlayer.username} ❤️ - ${topPlayer.score}</span> | <span style="color: #00FF00; text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);">Loser: ${rank8Player.username} - ${rank8Player.score}</span>`;
                    }
                }
            } catch (error) {
                console.error('Error loading top player:', error);
                
                const introTopPlayerName = document.getElementById('introTopPlayerName');
                const introTopPlayerScore = document.getElementById('introTopPlayerScore');
                if (introTopPlayerName) introTopPlayerName.textContent = 'Failed to load';
                if (introTopPlayerScore) introTopPlayerScore.textContent = '-';
                
                const introWorstPlayerName = document.getElementById('introWorstPlayerName');
                const introWorstPlayerScore = document.getElementById('introWorstPlayerScore');
                if (introWorstPlayerName) introWorstPlayerName.textContent = 'Failed to load';
                if (introWorstPlayerScore) introWorstPlayerScore.textContent = '-';
            }
        }

        // Control Icon Functions
        function initializeControlIcons() {
            // Exit Icon - Return to main menu
            if (exitIcon) {
                exitIcon.addEventListener('click', () => {
                    console.log('Exit icon clicked - returning to main menu');
                    // Stop music if playing
                    if (musicAudio && musicPlaying) {
                        musicAudio.pause();
                        musicAudio.currentTime = 0;
                        musicPlaying = false;
                        musicIcon.classList.remove('active');
                        currentMusicIndex = 0; // Reset to first song for next start
                        updateTrackIndicator();
                    }
                    // Reset game state
                    gameStarted = false;
                    gameOver = false;
                    score = 0;
                    coinCount = 100;
                    consecutiveWins = 0;
                    if (scoreBoard) {
                        scoreBoard.style.display = 'none';
                    }
                    // Hide game elements
                    const gameTopPlayerDisplay = document.getElementById('gameTopPlayerDisplay');
                    if (gameTopPlayerDisplay) {
                        gameTopPlayerDisplay.style.display = 'none';
                    }
                    // Show intro screen
                    if (introScreen) {
                        introScreen.style.display = 'flex';
                    }
                    // Reset canvas
                    if (ctx) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    // Reset game objects
                    resetGameObjects();
                    
                    // Reset pause icon
                    if (pauseIcon) {
                        pauseIcon.classList.remove('active');
                        pauseIcon.querySelector('i').className = 'fas fa-pause';
                        pauseIcon.title = 'Pause Game';
                    }
                });
            }

            // Music Icon - Toggle music and cycle through tracks
            if (musicIcon) {
                musicIcon.addEventListener('click', async () => {
                    console.log('Music icon clicked - cycling through tracks');
                    
                    if (musicPlaying) {
                        // If music is playing, switch to next track
                        currentMusicIndex = (currentMusicIndex + 1) % musicPlaylist.length;
                        console.log(`Switching to track ${currentMusicIndex + 1}/${musicPlaylist.length}: ${musicPlaylist[currentMusicIndex]}`);
                        
                        // Stop current song and play next one
                        if (musicAudio) {
                            musicAudio.pause();
                            musicAudio.removeEventListener('ended', handleSongEnd);
                            musicAudio.removeEventListener('error', handleSongError);
                            musicAudio = null;
                        }
                        
                        try {
                            await playNextSong();
                            updateTrackIndicator();
                        } catch (error) {
                            console.error('Failed to switch to next track:', error);
                            // If switching fails, try the next track
                            currentMusicIndex = (currentMusicIndex + 1) % musicPlaylist.length;
                            setTimeout(() => {
                                playNextSong();
                                updateTrackIndicator();
                            }, 500);
                        }
                    } else {
                        // Start music playlist from current index
                        try {
                            musicPlaying = true;
                            musicIcon.classList.add('active');
                            
                            console.log(`Starting music playlist at track ${currentMusicIndex + 1}/${musicPlaylist.length}: ${musicPlaylist[currentMusicIndex]}`);
                            console.log('Available songs:', musicPlaylist);
                            
                            await playNextSong();
                            updateTrackIndicator();
                        } catch (error) {
                            console.error('Failed to start music:', error);
                            musicPlaying = false;
                            musicIcon.classList.remove('active');
                            updateTrackIndicator();
                            alert('Could not start music. Please check browser permissions for audio playback.');
                        }
                    }
                });
            }

            // Pause Icon - Toggle game pause
            if (pauseIcon) {
                pauseIcon.addEventListener('click', () => {
                    console.log('Pause icon clicked - toggling pause');
                    gamePaused = !gamePaused;
                    
                    if (gamePaused) {
                        pauseIcon.classList.add('active');
                        pauseIcon.querySelector('i').className = 'fas fa-play';
                        pauseIcon.title = 'Resume Game';
                        console.log('Game paused');
                    } else {
                        pauseIcon.classList.remove('active');
                        pauseIcon.querySelector('i').className = 'fas fa-pause';
                        pauseIcon.title = 'Pause Game';
                        console.log('Game resumed');
                    }
                });
            }

            // Scores Icon - Open score instructions
            if (scoresIcon) {
                scoresIcon.addEventListener('click', () => {
                    window.open('scores.html', '_blank');
                });
            }
        }

        // Music playlist functions
        function updateTrackIndicator() {
            const trackIndicator = document.getElementById('musicTrackIndicator');
            const musicIcon = document.getElementById('musicIcon');
            if (trackIndicator) {
                if (musicPlaying) {
                    trackIndicator.textContent = currentMusicIndex + 1;
                    trackIndicator.style.display = 'flex';
                    // Update tooltip to show current track
                    if (musicIcon) {
                        const currentSong = musicPlaylist[currentMusicIndex];
                        musicIcon.title = `Current Track: ${currentSong} (${currentMusicIndex + 1}/${musicPlaylist.length}) - Click to switch tracks`;
                    }
                } else {
                    trackIndicator.style.display = 'none';
                    // Reset tooltip
                    if (musicIcon) {
                        musicIcon.title = 'Toggle Music - Click to start playlist';
                    }
                }
            }
        }
        
        function playNextSong() {
            return new Promise((resolve, reject) => {
                if (!musicPlaying) {
                    console.log('Music playback stopped');
                    resolve();
                    return;
                }
                
                // Create new audio element for current song
                if (musicAudio) {
                    musicAudio.pause();
                    musicAudio.removeEventListener('ended', handleSongEnd);
                    musicAudio.removeEventListener('error', handleSongError);
                    musicAudio = null;
                }
                
                const currentSong = musicPlaylist[currentMusicIndex];
                console.log(`Attempting to play: ${currentSong} (${currentMusicIndex + 1}/${musicPlaylist.length})`);
                
                musicAudio = new Audio(currentSong);
                musicAudio.volume = 0.5;
                musicAudio.preload = 'auto';
                
                // Add event listeners
                musicAudio.addEventListener('ended', handleSongEnd);
                musicAudio.addEventListener('error', () => {
                    reject(new Error(`Failed to load ${currentSong}`));
                    handleSongError();
                });
                musicAudio.addEventListener('loadstart', () => console.log(`Loading: ${currentSong}`));
                musicAudio.addEventListener('canplay', () => console.log(`Ready to play: ${currentSong}`));
                
                // Play the current song
                musicAudio.play().then(() => {
                    console.log(`Successfully playing: ${currentSong}`);
                    updateTrackIndicator();
                    resolve();
                }).catch(error => {
                    console.error(`Error playing ${currentSong}:`, error);
                    reject(error);
                    handleSongError();
                });
            });
        }
        
        function handleSongEnd() {
            console.log(`Song ended: ${musicPlaylist[currentMusicIndex]}`);
            if (musicPlaying) {
                // Move to next song in playlist
                currentMusicIndex = (currentMusicIndex + 1) % musicPlaylist.length;
                console.log(`Moving to next song: ${musicPlaylist[currentMusicIndex]}`);
                setTimeout(() => {
                    playNextSong();
                    updateTrackIndicator();
                }, 500); // Small delay between songs
            }
        }
        
        function handleSongError() {
            console.error(`Error with song: ${musicPlaylist[currentMusicIndex]}`);
            if (musicPlaying) {
                // Try the next song
                currentMusicIndex = (currentMusicIndex + 1) % musicPlaylist.length;
                console.log(`Skipping to next song: ${musicPlaylist[currentMusicIndex]}`);
                setTimeout(() => {
                    playNextSong();
                    updateTrackIndicator();
                }, 1000);
            }
        }

        // Reset game objects function
        function resetGameObjects() {
            // Reset all game objects to initial state
            coins = [];
            particles = [];
            obstacles = [];
            powerUps = [];
            lostBalls = 0;
            magnetActive = false;
            magnetTimer = 0;
            multiplierTimer = 0;
            coinMagnetTimer = 0;
            superParachuteTimer = 0;
            lastScoreMilestone = 0;
            bonusFlashTime = 0;
            parachuteFlashTime = 0;
            gamePaused = false;
            
                            // Reset auto-fire system
                lastFireTime = 0;
                autoFireTimer = 0;
                
                // Reset ball killer demon
                ballKiller = null;
                ballKillerSpawnTimer = 0;
                ballKillerActive = false;
                
                // Reset rocket
                rocket = null;
                rocketLanded = false;
            
            // Reset blue bombs
            blueBombs = [];
            blueBombSpawnTimer = 0;
            
            // Reset rocket
            rocket = null;
            rocketLanded = false;
            
            // Reset win zones
            bottomWinZone.glowTime = 0;
            bottomWinZone.hitCount = 0;
            bottomWinZone.lastHitTime = 0;
            bottomWinZone.fatTime = 0;
            bottomWinZone.width = bottomWinZone.baseWidth;
            bottomWinZone.directionChangeCooldown = 0;
            bottomWinZone.repelMode = false;
            bottomWinZone.repelTimer = 0;
            bottomWinZone.repelCooldown = 0;
            
            leftWinZone.glowTime = 0;
            leftWinZone.hitCount = 0;
            leftWinZone.lastHitTime = 0;
            leftWinZone.fatTime = 0;
            leftWinZone.width = leftWinZone.baseWidth;
            leftWinZone.directionChangeCooldown = 0;
            leftWinZone.repelMode = false;
            leftWinZone.repelTimer = 0;
            leftWinZone.repelCooldown = 0;
            
            rightWinZone.glowTime = 0;
            rightWinZone.hitCount = 0;
            rightWinZone.lastHitTime = 0;
            rightWinZone.fatTime = 0;
            rightWinZone.width = rightWinZone.baseWidth;
            rightWinZone.directionChangeCooldown = 0;
            rightWinZone.repelMode = false;
            rightWinZone.repelTimer = 0;
            rightWinZone.repelCooldown = 0;
            
            // Reset pusher
            pusher.x = 250;
            pusher.y = 100;
            pusher.speed = 4;
            pusher.direction = 1;
            
            // Reset music state
            if (musicAudio && musicPlaying) {
                musicAudio.pause();
                musicAudio.currentTime = 0;
                musicPlaying = false;
                musicIcon.classList.remove('active');
                currentMusicIndex = 0; // Reset to first track
                updateTrackIndicator();
            }
        }

        // BallKiller Demon class
        class BallKiller {
            constructor() {
                this.x = -100; // Start off-screen
                this.y = Math.random() * 400 + 100; // Random Y position
                this.width = 60;
                this.height = 60;
                this.speed = 3.3;
                this.suckRadius = 80;
                this.active = true;
                this.lifeTime = 0;
                this.maxLifeTime = 600; // 10 seconds at 60fps
                this.demonEyes = [
                    { x: -15, y: -10, size: 8 },
                    { x: 15, y: -10, size: 8 }
                ];
            }

            update() {
                if (!this.active) return false;
                
                // Move across screen
                this.x += this.speed;
                this.lifeTime++;
                
                // Suck up nearby red balls (coins)
                coins.forEach((coin, index) => {
                    const distance = Math.sqrt(
                        Math.pow(this.x - coin.x, 2) + Math.pow(this.y - coin.y, 2)
                    );
                    if (distance < this.suckRadius) {
                        // Create suck effect particles
                        for (let i = 0; i < 3; i++) {
                            particles.push(new Particle(coin.x, coin.y, 'suck'));
                        }
                        // Remove the ball
                        coins.splice(index, 1);
                        coinCount--;
                        console.log('Ball killer sucked up a ball!');
                    }
                });
                
                // Deactivate when off-screen or time expires
                if (this.x > 900 || this.lifeTime > this.maxLifeTime) {
                    this.active = false;
                    ballKillerActive = false;
                    console.log('Ball killer demon vanished');
                    return false;
                }
                
                return true;
            }

            draw() {
                if (!this.active) return;
                
                // Draw demon body (dark red with glow)
                ctx.save();
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.arc(
                    this.x * (canvas.width / 800), 
                    this.y * (canvas.height / 600), 
                    this.width / 2 * (canvas.width / 800), 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Draw demon eyes (glowing red)
                this.demonEyes.forEach(eye => {
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(
                        (this.x + eye.x) * (canvas.width / 800), 
                        (this.y + eye.y) * (canvas.height / 600), 
                        eye.size * (canvas.width / 800), 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                });
                
                // Draw suck radius (subtle effect)
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.lineWidth = 2 * (canvas.width / 800);
                ctx.beginPath();
                ctx.arc(
                    this.x * (canvas.width / 800), 
                    this.y * (canvas.height / 600), 
                    this.suckRadius * (canvas.width / 800), 
                    0, Math.PI * 2
                );
                ctx.stroke();
                
                ctx.restore();
            }
        }

        // BlueBomb class
        class BlueBomb {
            constructor() {
                this.x = Math.random() * 600 + 100; // Random X position
                this.y = -50; // Start above screen
                this.width = 40;
                this.height = 40;
                this.speed = 2;
                this.fuseTime = 0;
                this.maxFuseTime = 180; // 3 seconds at 60fps
                this.active = true;
                this.flashTime = 0;
                this.fuseLength = 20;
                this.fuseWidth = 3;
            }

            update() {
                if (!this.active) return false;
                
                // Move down
                this.y += this.speed;
                this.fuseTime++;
                
                // Flash when fuse is about to explode
                if (this.fuseTime > this.maxFuseTime * 0.7) {
                    this.flashTime = (this.flashTime + 1) % 10;
                }
                
                // Explode when fuse runs out or off screen
                if (this.fuseTime > this.maxFuseTime || this.y > 650) {
                    this.active = false;
                    console.log('Blue bomb exploded naturally');
                    return false;
                }
                
                return true;
            }

            draw() {
                if (!this.active) return;
                
                ctx.save();
                
                // Draw bomb body (blue with glow)
                ctx.shadowColor = '#0066ff';
                ctx.shadowBlur = this.flashTime > 5 ? 20 : 10;
                ctx.fillStyle = this.flashTime > 5 ? '#ff0000' : '#0066ff';
                ctx.beginPath();
                ctx.arc(
                    this.x * (canvas.width / 800), 
                    this.y * (canvas.height / 600), 
                    this.width / 2 * (canvas.width / 800), 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Draw fuse
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = this.fuseWidth * (canvas.width / 800);
                ctx.beginPath();
                ctx.moveTo(
                    this.x * (canvas.width / 800), 
                    (this.y - this.height / 2) * (canvas.height / 600)
                );
                ctx.lineTo(
                    this.x * (canvas.width / 800), 
                    (this.y - this.height / 2 - this.fuseLength) * (canvas.height / 600)
                );
                ctx.stroke();
                
                // Draw fuse tip (spark effect)
                if (this.fuseTime > this.maxFuseTime * 0.5) {
                    ctx.fillStyle = this.flashTime > 5 ? '#ffff00' : '#ff6600';
                    ctx.beginPath();
                    ctx.arc(
                        this.x * (canvas.width / 800), 
                        (this.y - this.height / 2 - this.fuseLength) * (canvas.height / 600), 
                        3 * (canvas.width / 800), 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Rocket class
        class Rocket {
            constructor() {
                this.x = 850; // Start off-screen to the right
                this.y = 200; // Landing position
                this.width = 80;
                this.height = 120;
                this.speed = 3;
                this.landed = false;
                this.landingTime = 0;
                this.maxLandingTime = 300; // 5 seconds at 60fps
                this.engineFlame = 0;
                this.smokeParticles = [];
                this.landingEffect = false;
            }

            update() {
                if (this.landed) {
                    this.landingTime++;
                    if (this.landingTime > this.maxLandingTime) {
                        return false; // Remove rocket after landing time
                    }
                    return true;
                }

                // Move rocket towards landing position
                this.x -= this.speed;
                
                // Add engine flame effect
                this.engineFlame = (this.engineFlame + 1) % 10;
                
                // Create smoke trail
                if (Math.random() < 0.3) {
                    this.smokeParticles.push({
                        x: this.x + this.width,
                        y: this.y + this.height / 2,
                        life: 30,
                        vx: Math.random() * 2 - 1,
                        vy: Math.random() * 2 - 1
                    });
                }
                
                // Update smoke particles
                this.smokeParticles = this.smokeParticles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    return particle.life > 0;
                });
                
                // Check if rocket has landed
                if (this.x <= 750) { // Land at the right side of screen
                    this.x = 750;
                    this.landed = true;
                    this.landingEffect = true;
                    
                    // Create landing explosion effect
                    for (let i = 0; i < 25; i++) {
                        particles.push(new Particle(this.x, this.y + this.height, 'explosion'));
                    }
                    
                    // Play landing sound
                    playSound(150, 'sawtooth', 1.5, 0.6);
                    console.log('Rocket has landed!');
                }
                
                return true;
            }

            draw() {
                ctx.save();
                
                // Draw smoke particles
                this.smokeParticles.forEach(particle => {
                    ctx.beginPath();
                    ctx.arc(
                        particle.x * (canvas.width / 800),
                        particle.y * (canvas.height / 600),
                        3 * (canvas.width / 800),
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = `rgba(100, 100, 100, ${particle.life / 30})`;
                    ctx.fill();
                });
                
                // Draw rocket body
                ctx.fillStyle = '#ff4444';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.fillRect(
                    this.x * (canvas.width / 800),
                    this.y * (canvas.height / 600),
                    this.width * (canvas.width / 800),
                    this.height * (canvas.height / 600)
                );
                
                // Draw rocket nose cone
                ctx.beginPath();
                ctx.moveTo(
                    this.x * (canvas.width / 800),
                    this.y * (canvas.height / 600)
                );
                ctx.lineTo(
                    (this.x + this.width / 2) * (canvas.width / 800),
                    (this.y - 20) * (canvas.height / 600)
                );
                ctx.lineTo(
                    (this.x + this.width) * (canvas.width / 800),
                    this.y * (canvas.height / 600)
                );
                ctx.fillStyle = '#ff6666';
                ctx.fill();
                
                // Draw rocket fins
                ctx.fillStyle = '#cc3333';
                ctx.fillRect(
                    this.x * (canvas.width / 800),
                    (this.y + this.height - 20) * (canvas.height / 600),
                    15 * (canvas.width / 800),
                    20 * (canvas.height / 600)
                );
                ctx.fillRect(
                    (this.x + this.width - 15) * (canvas.width / 800),
                    (this.y + this.height - 20) * (canvas.height / 600),
                    15 * (canvas.width / 800),
                    20 * (canvas.height / 600)
                );
                
                // Draw engine flame
                if (!this.landed) {
                    ctx.fillStyle = this.engineFlame > 5 ? '#ffff00' : '#ff6600';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(
                        this.x * (canvas.width / 800),
                        (this.y + this.height) * (canvas.height / 600)
                    );
                    ctx.lineTo(
                        (this.x + this.width / 2) * (canvas.width / 800),
                        (this.y + this.height + 30) * (canvas.height / 600)
                    );
                    ctx.lineTo(
                        (this.x + this.width) * (canvas.width / 800),
                        (this.y + this.height) * (canvas.height / 600)
                    );
                    ctx.fill();
                }
                
                // Draw rocket windows
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(
                    (this.x + this.width / 2) * (canvas.width / 800),
                    (this.y + this.height / 3) * (canvas.height / 600),
                    8 * (canvas.width / 800),
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Draw landing effect
                if (this.landingEffect && this.landingTime < 60) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${1 - this.landingTime / 60})`;
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 30;
                    ctx.fillRect(
                        (this.x - 50) * (canvas.width / 800),
                        (this.y + this.height - 10) * (canvas.height / 600),
                        (this.width + 100) * (canvas.width / 800),
                        20 * (canvas.height / 600)
                    );
                }
                
                ctx.restore();
            }
        }

        // Start game function
        function startGame() {
            introScreen.style.display = 'none';
            if (scoreBoard) {
                scoreBoard.style.display = 'flex';
            }
            // Show top player display above game window
            const gameTopPlayerDisplay = document.getElementById('gameTopPlayerDisplay');
            if (gameTopPlayerDisplay) {
                gameTopPlayerDisplay.style.display = 'block';
            }
            gameStarted = true;
            // Initialize auto-fire system
            lastFireTime = Date.now();
            autoFireTimer = 0;
            
            // Test: Spawn a blue bomb immediately for testing
            const testBomb = new BlueBomb();
            blueBombs.push(testBomb);
            console.log('Test blue bomb spawned at start!');
            canvas.addEventListener('pointerdown', handleInput);
            gameLoop();
            console.log('Game started');
        }

        // Load top player when page loads (for intro screen)
        loadTopPlayer();
        if (introScreen) {
            introScreen.style.display = 'flex';
        }

        // Event listeners for intro screen
        if (startButton) {
            startButton.addEventListener('click', startGame);
            startButton.addEventListener('touchstart', startGame);
        }
        
        // Add key press event listener for splash screen and intro screen
        document.addEventListener('keydown', (e) => {
            // Handle splash screen transition
            if (splashScreen && splashScreen.style.display !== 'none') {
                splashScreen.style.display = 'none';
                introScreen.style.display = 'flex';
                console.log('Splash screen dismissed, showing intro screen');
                return;
            }
            
            // Handle intro screen to game transition
            if (!gameStarted && introScreen.style.display !== 'none') {
                startGame();
            }
        });
        
        // Add click/touch event listener for splash screen and intro screen
        document.addEventListener('click', (e) => {
            // Handle splash screen transition
            if (splashScreen && splashScreen.style.display !== 'none') {
                splashScreen.style.display = 'none';
                introScreen.style.display = 'flex';
                console.log('Splash screen dismissed, showing intro screen');
                return;
            }
            
            // Handle intro screen to game transition
            if (!gameStarted && introScreen.style.display !== 'none') {
                startGame();
            }
        });

        // QQ key to set balls to 0 (for testing)
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'q') {
                const currentTime = Date.now();
                if (currentTime - lastQPress < 300) { // 300ms window for QQ
                    coinCount = 0;
                    console.log('QQ pressed - balls set to 0');
                }
                lastQPress = currentTime;
            }
        });

        let lastQPress = 0;

        // Load top player when page loads (for intro screen)
        loadTopPlayer();
        
        // Initialize control icons
        initializeControlIcons();

        // Open Franksgames website when footer logo is clicked
        const franksgamesLogo = document.getElementById('franksgamesLogo');
        if (franksgamesLogo) {
            franksgamesLogo.addEventListener('click', () => {
                window.open('https://franks.games', '_blank');
            });
        }

        // Audio context (initialized on first input)
        let audioCtx = null;
        function initAudioContext() {
            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioCtx.state === 'suspended') {
                        audioCtx.resume();
                    }
                    console.log('Audio context initialized');
                }
            } catch (error) {
                console.error('Audio context initialization failed:', error);
            }
        }

        function playSound(frequency, type, duration, volume = 0.5) {
            try {
                if (!audioCtx) return;
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                oscillator.stop(audioCtx.currentTime + duration);
            } catch (error) {
                console.error('Play sound error:', error);
            }
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * starCanvas.width,
                    y: Math.random() * starCanvas.height,
                    size: Math.random() * 2 + 1,
                    vx: (Math.random() - 0.5) * 0.2,
                    vy: (Math.random() - 0.5) * 0.2
                });
            }
        }

        let galaxies = [];

        function initGalaxies() {
            galaxies = [];
            const galaxyCount = 3;
            for (let i = 0; i < galaxyCount; i++) {
                galaxies.push({
                    x: Math.random() * starCanvas.width,
                    y: Math.random() * starCanvas.height,
                    radius: Math.random() * 40 + 20,
                    angle: Math.random() * Math.PI * 2,
                    speed: 0.001 + Math.random() * 0.003
                });
            }
        }

        function drawStars() {
            starCtx.fillStyle = '#ffffff';
            stars.forEach(star => {
                star.x += star.vx;
                star.y += star.vy;
                if (star.x < 0) star.x = starCanvas.width;
                if (star.x > starCanvas.width) star.x = 0;
                if (star.y < 0) star.y = starCanvas.height;
                if (star.y > starCanvas.height) star.y = 0;
                starCtx.beginPath();
                starCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                starCtx.fill();
            });
        }

        function drawGalaxies() {
            starCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            starCtx.lineWidth = 0.5;
            galaxies.forEach(galaxy => {
                galaxy.angle += galaxy.speed;
                const maxAngle = Math.PI * 4;
                starCtx.beginPath();
                for (let a = 0; a <= maxAngle; a += 0.1) {
                    const r = galaxy.radius * (a / maxAngle);
                    const x = galaxy.x + r * Math.cos(a + galaxy.angle);
                    const y = galaxy.y + r * Math.sin(a + galaxy.angle);
                    if (a === 0) {
                        starCtx.moveTo(x, y);
                    } else {
                        starCtx.lineTo(x, y);
                    }
                }
                starCtx.stroke();
            });
        }

        function starLoop() {
            starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
            drawGalaxies();
            drawStars();
            requestAnimationFrame(starLoop);
        }

        // Responsive canvas size
        function resizeCanvas() {
            try {
                const aspectRatio = 800 / 600;
                const maxWidth = window.innerWidth * 0.98; // Increased from 0.95 to 0.98
                const maxHeight = window.innerHeight * 0.98; // Increased from 0.95 to 0.98
                let width = maxWidth;
                let height = width / aspectRatio;
                if (height > maxHeight) {
                    height = maxHeight;
                    width = height * aspectRatio;
                }
                // Make canvas 50% bigger again
                const isMobile = /Android|iPhone|iPad|Mobile/i.test(navigator.userAgent);
                if (isMobile) {
                    height *= 10.5; // 50% bigger than 7.0 = 10.5x height for mobile
                    width = height * aspectRatio;
                    if (width > maxWidth) {
                        width = maxWidth;
                        height = width / aspectRatio;
                    }
                } else {
                    // 50% bigger desktop canvas again
                    height *= 9.0; // 50% bigger than 6.0 = 9x height for desktop
                    width = height * aspectRatio;
                    if (width > maxWidth) {
                        width = maxWidth;
                        height = width / aspectRatio;
                    }
                }
                canvas.width = width;
                canvas.height = height;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                starCanvas.width = width;
                starCanvas.height = height;
                starCanvas.style.width = `${width}px`;
                starCanvas.style.height = `${height}px`;
                initStars();
                initGalaxies();
                console.log('Canvas resized:', width, height, 'Mobile:', isMobile);
            } catch (error) {
                console.error('Resize canvas error:', error);
            }
        }
        resizeCanvas();
        initStars();
        initGalaxies();
        starLoop();
        window.addEventListener('resize', resizeCanvas);

        // Game objects (declared earlier to avoid initialization errors)

        // UFO class
        class UFO {
            constructor() {
                this.x = 0;
                this.y = 150;
                this.width = 60;
                this.height = 30;
                this.vx = 8; // Faster movement
                this.vy = 0;
                this.spawned = true;
                this.time = 0;
                this.amplitude = 50;
                this.frequency = 0.02;
                this.shootTimer = 0;
                this.shootInterval = 20; // Shoot every 0.33 seconds (20fps at 60fps)
                this.laserSpeed = 12; // Faster laser speed
                this.lasers = [];
                this.maxLifetime = 3600; // Stay on screen for 60 seconds (3600 frames at 60fps)
                this.lifetime = 0;
            }

            draw() {
                try {
                    // Draw UFO body
                    ctx.beginPath();
                    ctx.ellipse(this.x * (canvas.width / 800), this.y * (canvas.height / 600), 
                                this.width * (canvas.width / 800) / 2, this.height * (canvas.height / 600) / 2, 
                                0, 0, Math.PI * 2);
                    ctx.fillStyle = '#c0c0c0';
                    ctx.fill();
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.font = `${10 * (canvas.width / 800)}px 'Orbitron', sans-serif`;
                    ctx.fillStyle = '#00ff00';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('UFO', this.x * (canvas.width / 800), this.y * (canvas.height / 600));
                    
                    // Draw laser projectiles
                    this.lasers.forEach(laser => {
                        ctx.beginPath();
                        ctx.arc(laser.x * (canvas.width / 800), laser.y * (canvas.height / 600), 
                               3 * (canvas.width / 800), 0, Math.PI * 2);
                        ctx.fillStyle = '#ff0000'; // Red laser
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 5;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Draw laser trail
                        ctx.beginPath();
                        ctx.moveTo(laser.x * (canvas.width / 800), laser.y * (canvas.height / 600));
                        ctx.lineTo((laser.x - laser.vx * 2) * (canvas.width / 800), 
                                  (laser.y - laser.vy * 2) * (canvas.height / 600));
                        ctx.strokeStyle = '#ff6666';
                        ctx.lineWidth = 2 * (canvas.width / 800);
                        ctx.stroke();
                    });
                } catch (error) {
                    console.error('UFO draw error:', error);
                }
            }

            update() {
                try {
                    this.time += 1;
                    this.lifetime += 1;
                    this.x += this.vx;
                    
                    // Add sine wave movement for more interesting flight pattern
                    this.y = 150 + Math.sin(this.time * this.frequency) * this.amplitude;
                    
                    // Shooting logic
                    this.shootTimer++;
                    if (this.shootTimer >= this.shootInterval && coins.length > 0) {
                        this.shootAtBalls();
                        this.shootTimer = 0;
                    }
                    
                    // Update lasers
                    this.lasers = this.lasers.filter(laser => {
                        laser.x += laser.vx;
                        laser.y += laser.vy;
                        
                        // Check laser collision with balls
                        coins.forEach((coin, index) => {
                            const coinLogicalX = coin.x / (canvas.width / 800);
                            const coinLogicalY = coin.y / (canvas.height / 600);
                            const dx = laser.x - coinLogicalX;
                            const dy = laser.y - coinLogicalY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 15) { // Laser hit radius
                                // Create destruction effect particles
                                for (let i = 0; i < 6; i++) {
                                    particles.push(new Particle(coinLogicalX, coinLogicalY, 'ufo'));
                                }
                                // Remove the ball
                                coins.splice(index, 1);
                                coinCount--;
                                console.log('UFO laser destroyed a ball!');
                                return false; // Remove this laser
                            }
                        });
                        
                        // Remove laser if it goes off screen
                        return laser.x > 0 && laser.x < 800 && laser.y > 0 && laser.y < 600;
                    });
                    
                    // Check for nearby balls and destroy them (close range)
                    const destroyRadius = 60; // Radius around UFO that destroys balls
                    coins.forEach((coin, index) => {
                        const coinLogicalX = coin.x / (canvas.width / 800);
                        const coinLogicalY = coin.y / (canvas.height / 600);
                        const dx = this.x - coinLogicalX;
                        const dy = this.y - coinLogicalY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < destroyRadius) {
                            // Create destruction effect particles
                            for (let i = 0; i < 8; i++) {
                                particles.push(new Particle(coinLogicalX, coinLogicalY, 'ufo'));
                            }
                            // Remove the ball
                            coins.splice(index, 1);
                            coinCount--;
                            console.log('UFO destroyed a ball at close range!');
                        }
                    });
                    
                    // Leave screen after max lifetime or when reaching right edge
                    if (this.lifetime >= this.maxLifetime || this.x > 800) {
                        this.spawned = false;
                    }
                } catch (error) {
                    console.error('UFO update error:', error);
                }
            }
            
            shootAtBalls() {
                if (coins.length === 0) return;
                
                // Find the closest ball to shoot at
                let closestBall = null;
                let closestDistance = Infinity;
                
                coins.forEach(coin => {
                    const coinLogicalX = coin.x / (canvas.width / 800);
                    const coinLogicalY = coin.y / (canvas.height / 600);
                    const dx = this.x - coinLogicalX;
                    const dy = this.y - coinLogicalY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestBall = { x: coinLogicalX, y: coinLogicalY };
                    }
                });
                
                if (closestBall) {
                    // Calculate direction to the ball
                    const dx = closestBall.x - this.x;
                    const dy = closestBall.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const vx = (dx / distance) * this.laserSpeed;
                        const vy = (dy / distance) * this.laserSpeed;
                        
                        // Create laser projectile
                        this.lasers.push({
                            x: this.x,
                            y: this.y,
                            vx: vx,
                            vy: vy
                        });
                        
                        console.log('UFO fired laser at ball!');
                    }
                }
            }
        }



        async function loadServerHighScores() {
            try {
                // Check if Firebase is initialized
                if (!db) {
                    console.warn('⚠️ Firebase not initialized, returning empty scores');
                    return [];
                }
                
                const snapshot = await db.collection('leaderboard')
                    .orderBy('score', 'desc')
                    .limit(10)
                    .get();
                
                const scores = [];
                snapshot.forEach(doc => {
                    scores.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                
                console.log('Firebase scores loaded:', scores);
                return scores;
            } catch (error) {
                console.error('Load Firebase high scores error:', error);
                return [];
            }
        }

        async function updateLeaderboardData() {
            try {
                const scores = await loadServerHighScores();
                leaderboardData = scores;
            } catch (error) {
                console.error('Error updating leaderboard data:', error);
            }
        }

        async function displayHighScores() {
            try {
                const globalScores = await loadServerHighScores();
                globalHighScoreList.innerHTML = '';
                if (globalScores.length === 0) {
                    const li = document.createElement('li');
                    li.textContent = 'No global scores yet';
                    globalHighScoreList.appendChild(li);
                } else {
                    // Display top 4 players as Champions (golden)
                    const topPlayers = globalScores.slice(0, 4);
                    topPlayers.forEach((entry, index) => {
                        const li = document.createElement('li');
                        li.style.color = '#FFD700'; // Golden color for champions
                        li.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8)';
                        const rank = (index + 1).toString().padStart(2, ' ');
                        const score = entry.score.toString().padStart(6, ' ');
                        
                        // Format date
                        const dateStr = formatScoreDate(entry.timestamp);
                        
                        li.innerHTML = `🏆 Rank ${rank}: ${entry.username.padEnd(15)} - ${score}<br><span style="font-size: 10px; color: #ccc; font-weight: normal;">${dateStr}</span>`;
                        globalHighScoreList.appendChild(li);
                    });
                    
                    // Add separator and "Losers" header if we have both champions and losers
                    if (globalScores.length > 4) {
                        const separator = document.createElement('li');
                        separator.style.color = '#666';
                        separator.style.fontSize = '14px';
                        separator.style.textAlign = 'center';
                        separator.style.margin = '10px 0';
                        separator.textContent = '──────────';
                        globalHighScoreList.appendChild(separator);
                        
                        // Add "Losers" header
                        const losersHeader = document.createElement('li');
                        losersHeader.style.color = '#00FF00';
                        losersHeader.style.fontSize = '18px';
                        losersHeader.style.fontWeight = 'bold';
                        losersHeader.style.textAlign = 'center';
                        losersHeader.style.margin = '15px 0 10px 0';
                        losersHeader.style.textShadow = '0 0 10px rgba(0, 255, 0, 0.8)';
                        losersHeader.textContent = 'Losers';
                        globalHighScoreList.appendChild(losersHeader);
                    }
                    
                    // Display players 5-8 as Losers (green) - show up to 4 losers
                    const losersCount = Math.min(4, globalScores.length - 4);
                    if (losersCount > 0) {
                        const losers = globalScores.slice(4, 4 + losersCount);
                        losers.forEach((entry, index) => {
                            const li = document.createElement('li');
                            li.style.color = '#00FF00'; // Green color for losers
                            li.style.textShadow = '0 0 10px rgba(0, 255, 0, 0.8)';
                            const rank = 5 + index; // Players 5, 6, 7, 8
                            const rankStr = rank.toString().padStart(2, ' ');
                            const score = entry.score.toString().padStart(6, ' ');
                            
                            // Format date
                            const dateStr = formatScoreDate(entry.timestamp);
                            
                            li.innerHTML = `💚 Rank ${rankStr}: ${entry.username.padEnd(15)} - ${score}<br><span style="font-size: 10px; color: #ccc; font-weight: normal;">${dateStr}</span>`;
                            globalHighScoreList.appendChild(li);
                        });
                    }
                }

                // Check if player's score is high enough to make it onto the leaderboard
                const minScoreForLeaderboard = globalScores.length >= 10 ? globalScores[globalScores.length - 1].score : 0;
                const hasQualifiedScore = score > minScoreForLeaderboard;

                // Show/hide name input based on whether they qualified
                const nameInputSection = document.getElementById('nameInputSection');
                if (hasQualifiedScore) {
                    nameInputSection.style.display = 'block';
                    nameInputSection.innerHTML = '<input id="usernameInput" type="text" placeholder="Enter your name" maxlength="20">';
                    // Re-get the element references after recreating them
                    const newUsernameInput = document.getElementById('usernameInput');
                    if (newUsernameInput) {
                        newUsernameInput.focus();
                        // Add event listener for Enter key to save score
                        newUsernameInput.addEventListener('keydown', async (e) => {
                            if (e.key === 'Enter') {
                                const username = newUsernameInput.value.trim();
                                if (username) {
                                    try {
                                        // Check if Firebase is initialized
                                        if (!db) {
                                            console.warn('⚠️ Firebase not initialized, cannot save score');
                                            alert('Firebase not ready. Please try again in a moment.');
                                            return;
                                        }
                                        
                                        // Save score to Firebase
                                        const scoreData = {
                                            username: username,
                                            score: score,
                                            timestamp: new Date(),
                                            createdAt: firebase.firestore.FieldValue.serverTimestamp()
                                        };
                                        
                                        console.log('Attempting to save score:', scoreData);
                                        const docRef = await db.collection('leaderboard').add(scoreData);
                                        console.log('Score saved to Firebase successfully. Document ID:', docRef.id);
                                        console.log('Score saved to Firebase:', score, username);
                                        
                                        // Show success message
                                        const nameInputSection = document.getElementById('nameInputSection');
                                        nameInputSection.innerHTML = '<p style="color: #00ff00; font-size: 16px;">✅ Score saved successfully!</p>';
                                        
                                        // Update the leaderboard display
                                        await loadTopPlayer();
                                        await displayHighScores();
                                    } catch (error) {
                                        console.error('Error saving score to Firebase:', error);
                                        alert('Failed to save score. Please try again.');
                                    }
                                }
                            }
                        });
                    }
                } else {
                    nameInputSection.style.display = 'block';
                    nameInputSection.innerHTML = '<p style="color: #ff6b6b; font-size: 16px;">Score too low for leaderboard - try again!</p>';
                }

                gameOverScreen.style.display = 'block';
                if (scoreBoard) {
                    scoreBoard.style.display = 'none';
                }
                console.log('Game over screen displayed, qualified for leaderboard:', hasQualifiedScore);
            } catch (error) {
                console.error('Display high scores error:', error);
            }
        }

        function restartGame() {
            try {
                score = 0;
                coinCount = 100;
                ufo = null;
                ufoSpawnTimer = 0;
                lastScoreMilestone = 0;
                bonusFlashTime = 0;
                parachuteFlashTime = 0;
                lostBalls = 0;
                coins = [];
                particles = [];
                obstacles = [];
                powerUps = [];
                magnetActive = false;
                magnetTimer = 0;
                consecutiveWins = 0;
                multiplierTimer = 0;
                coinMagnetTimer = 0;
                superParachuteTimer = 0;
                gameOver = false;
                resizeTimer = 0;
                resizeInterval = Math.floor(Math.random() * (240 - 120 + 1)) + 120;
                bottomWinZone.width = 100;
                leftWinZone.width = 50;
                

                leftWinZone.height = 100;
                rightWinZone.width = 50;
                rightWinZone.height = 100;
                pusher.width = 300;
                pusher.speed = 4;
                gameOverScreen.style.display = 'none';
                if (scoreBoard) {
                    scoreBoard.style.display = 'none';
                }
                usernameInput.value = '';
                
                // Show intro screen again instead of starting game immediately
                introScreen.style.display = 'flex';
                gameStarted = false;
                canvas.removeEventListener('pointerdown', handleInput);
                loadTopPlayer(); // Refresh leaderboard
                console.log('Game restarted - showing intro screen');
            } catch (error) {
                console.error('Restart game error:', error);
            }
        }

        restartButton.addEventListener('click', restartGame);

        // Helper function to format dates consistently
        function formatScoreDate(timestamp) {
            try {
                const date = timestamp ? new Date(timestamp.toDate ? timestamp.toDate() : timestamp) : new Date();
                return date.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (error) {
                console.error('Error formatting date:', error);
                return 'Unknown';
            }
        }

        // Debug function to test date formatting (can be called from console)
        window.testDateFormatting = function() {
            console.log('🧪 Testing date formatting...');
            const testDates = [
                new Date(),
                { toDate: () => new Date() },
                null,
                undefined
            ];
            
            testDates.forEach((date, index) => {
                const formatted = formatScoreDate(date);
                console.log(`Test ${index + 1}:`, date, '→', formatted);
            });
        };

        // Debug function to test Firebase score saving (can be called from console)
        window.testFirebaseScore = async function() {
            try {
                if (!db) {
                    console.error('❌ Firebase not initialized');
                    return false;
                }
                
                console.log('🧪 Testing Firebase score saving...');
                const testScore = {
                    username: 'TEST_USER_' + Date.now(),
                    score: Math.floor(Math.random() * 1000) + 100,
                    timestamp: new Date(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                const docRef = await db.collection('leaderboard').add(testScore);
                console.log('✅ Test score saved successfully! Document ID:', docRef.id);
                console.log('📊 Test score data:', testScore);
                
                // Clean up test score after 1 minute
                setTimeout(async () => {
                    try {
                        await docRef.delete();
                        console.log('🧹 Test score cleaned up');
                    } catch (error) {
                        console.error('❌ Failed to clean up test score:', error);
                    }
                }, 60000);
                
                return true;
            } catch (error) {
                console.error('❌ Test score saving failed:', error);
                return false;
            }
        };

        // PowerUp class
        class PowerUp {
            constructor() {
                this.x = Math.random() * (800 - 20);
                this.y = 200;
                this.radius = 10;
                this.vx = (Math.random() > 0.5 ? 1 : -1) * 2;
                const types = ['multiplier', 'coinMagnet', 'extraCoin', 'superParachute'];
                this.type = types[Math.floor(Math.random() * types.length)];
            }

            draw() {
                try {
                    ctx.beginPath();
                    ctx.arc(this.x * (canvas.width / 800), this.y * (canvas.height / 600), this.radius * (canvas.width / 800), 0, Math.PI * 2);
                    ctx.fillStyle = this.type === 'multiplier' ? '#ff0000' : this.type === 'coinMagnet' ? '#00b7eb' : this.type === 'extraCoin' ? '#ffff00' : '#ffffff';
                    ctx.fill();
                    ctx.font = `${10 * (canvas.width / 800)}px 'Orbitron', sans-serif`;
                    ctx.fillStyle = '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.type === 'multiplier' ? '2x' : this.type === 'coinMagnet' ? 'M' : this.type === 'extraCoin' ? '+5' : 'S', 
                                 this.x * (canvas.width / 800), this.y * (canvas.height / 600));
                } catch (error) {
                    console.error('PowerUp draw error:', error);
                }
            }

            update() {
                try {
                    this.x += this.vx;
                    if (this.x < 0 || this.x + this.radius * 2 > 800) {
                        this.vx *= -1;
                    }
                } catch (error) {
                    console.error('PowerUp update error:', error);
                }
            }
        }

        // Particle class for effects
        class Particle {
            constructor(x, y, type) {
                // Limit particles on low-performance devices
                if (particles.length >= PERFORMANCE_SETTINGS.maxParticles) {
                    return null; // Don't create particle if at limit
                }
                
                this.x = x * canvas.width / 800;
                this.y = y * canvas.height / 600;
                this.size = (type === 'spark' || type === 'parachute' || type === 'magnet' || type === 'miss' || type === 'ufo' || type === 'bonus' || type === 'suck' || type === 'demon' || type === 'bomb' || type === 'explosion' || type === 'direction' || type === 'repel') ? (Math.random() * 2 + 1) * (canvas.width / 800) : (Math.random() * 5 + 2) * (canvas.width / 800);
                this.vx = (type === 'spark' || type === 'parachute' || type === 'magnet' || type === 'miss' || type === 'ufo' || type === 'bonus' || type === 'suck' || type === 'demon' || type === 'bomb' || type === 'explosion' || type === 'direction' || type === 'repel') ? (Math.random() - 0.5) * 4 : (Math.random() - 0.5) * 8;
                this.vy = (type === 'spark' || type === 'parachute' || type === 'magnet' || type === 'miss' || type === 'ufo' || type === 'bonus' || type === 'suck' || type === 'demon' || type === 'bomb' || type === 'explosion' || type === 'direction' || type === 'repel') ? (Math.random() - 0.5) * 4 : (Math.random() - 0.5) * 8;
                this.life = type === 'spark' || type === 'parachute' || type === 'magnet' || type === 'miss' || type === 'ufo' || type === 'bonus' || type === 'suck' || type === 'demon' || type === 'bomb' || type === 'explosion' || type === 'direction' || type === 'repel' ? PERFORMANCE_SETTINGS.particleLifetime / 2 : PERFORMANCE_SETTINGS.particleLifetime;
                this.color = type === 'spark' || type === 'parachute' ? '#ffffff' : type === 'knockback' ? '#ffa500' : type === 'magnet' ? '#00b7eb' : type === 'miss' || type === 'bonus' ? '#ffff00' : type === 'ufo' ? '#00ff00' : type === 'suck' ? '#ff0000' : type === 'demon' ? '#8b0000' : type === 'bomb' ? '#0066ff' : type === 'explosion' ? '#ff6600' : type === 'direction' ? '#ff00ff' : type === 'repel' ? '#ff8800' : `hsl(${Math.random() * 360}, 100%, 50%)`;
            }

            draw() {
                try {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                } catch (error) {
                    console.error('Particle draw error:', error);
                }
            }

            update() {
                try {
                    this.x += this.vx * (canvas.width / 800);
                    this.y += this.vy * (canvas.height / 600);
                    this.vy += 0.1;
                    this.size *= 0.95;
                    this.life--;
                    return this.life <= 0;
                } catch (error) {
                    console.error('Particle update error:', error);
                    return true;
                }
            }
        }

        // Coin class
        class Coin {
            constructor(x, y) {
                try {
                    this.x = x * canvas.width / 800;
                    this.y = y * canvas.height / 600;
                    this.radius = 15 * (canvas.width / 800);
                    this.vy = 1; // Start with some downward velocity for faster gameplay
                    this.vx = (Math.random() - 0.5) * 2; // Random horizontal velocity for more action
                    this.onPusher = false;
                    this.glowTime = 0;
                    this.hasParachute = false;
                    this.flashTime = 0;
                    this.lastObstacleHitTime = 0;
                    this.collisionFlashTime = 0;
                    this.collisionProcessed = false;
                    this.shakeTimer = 0;
                    this.shakeIntensity = 0;
                    playSound(600, 'square', 0.1, 0.3);
                    // Reduced particle count for tablets
                    const particleCount = isLowPerformance ? 2 : 5;
                    for (let i = 0; i < particleCount; i++) {
                        const particle = new Particle(x, y, 'miss');
                        if (particle) particles.push(particle);
                    }
                } catch (error) {
                    console.error('Coin constructor error:', error);
                }
            }

            draw() {
                try {
                    // Calculate shake offset
                    let shakeX = 0;
                    let shakeY = 0;
                    if (this.shakeIntensity > 0) {
                        shakeX = (Math.random() - 0.5) * this.shakeIntensity * (canvas.width / 800);
                        shakeY = (Math.random() - 0.5) * this.shakeIntensity * (canvas.height / 600);
                    }
                    
                    const drawX = this.x + shakeX;
                    const drawY = this.y + shakeY;
                    
                    if (this.flashTime > 0) {
                        ctx.beginPath();
                        ctx.arc(drawX, drawY, this.radius * 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 0, ${this.flashTime / 10})`;
                        ctx.fill();
                        this.flashTime--;
                    }
                    
                    // Collision flash effect
                    if (this.collisionFlashTime > 0) {
                        ctx.beginPath();
                        ctx.arc(drawX, drawY, this.radius * 1.3, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${this.collisionFlashTime / 10})`;
                        ctx.fill();
                        this.collisionFlashTime--;
                    }

                    ctx.beginPath();
                    ctx.arc(drawX, drawY, this.radius, 0, Math.PI * 2);
                    
                    // Optimized rendering for tablets
                    if (PERFORMANCE_SETTINGS.enableShadows) {
                        const gradient = ctx.createRadialGradient(this.x - 5 * (canvas.width / 800), this.y - 5 * (canvas.height / 600), 2 * (canvas.width / 800), this.x, this.y, this.radius);
                        gradient.addColorStop(0, '#ff3333');
                        gradient.addColorStop(1, '#cc0000');
                        ctx.fillStyle = gradient;
                        ctx.shadowColor = (this.glowTime > 0 || superParachuteTimer > 0) ? '#00ffcc' : '#ff3333';
                        ctx.shadowBlur = (this.glowTime > 0 || superParachuteTimer > 0) ? 15 : 10;
                    } else {
                        ctx.fillStyle = '#ff3333';
                    }
                    ctx.fill();
                    if (PERFORMANCE_SETTINGS.enableShadows) {
                        ctx.shadowBlur = 0;
                    }
                    if (this.glowTime > 0) this.glowTime--;

                    if (this.hasParachute) {
                        ctx.beginPath();
                        ctx.arc(drawX, drawY - this.radius - 5 * (canvas.height / 600), this.radius, Math.PI, 0);
                        ctx.strokeStyle = superParachuteTimer > 0 ? '#00ffcc' : '#ffffff';
                        if (PERFORMANCE_SETTINGS.enableShadows) {
                            ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                            ctx.shadowBlur = 5;
                        }
                        ctx.lineWidth = 2 * (canvas.width / 800);
                        ctx.stroke();
                        if (PERFORMANCE_SETTINGS.enableShadows) {
                            ctx.shadowBlur = 0;
                        }
                        // Reduced parachute particles for tablets
                        if (Math.random() < (isLowPerformance ? 0.05 : 0.1)) {
                            const particle = new Particle(this.x / (canvas.width / 800), this.y / (canvas.height / 600) + this.radius / (canvas.height / 600), 'parachute');
                            if (particle) particles.push(particle);
                        }
                        
                        // Visual indicator when guidance is active
                        if (tapActive) {
                            const dx = lastTapX - this.x / (canvas.width / 800);
                            const dy = lastTapY - this.y / (canvas.height / 600);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 200) {
                                ctx.beginPath();
                                ctx.moveTo(drawX, drawY);
                                ctx.lineTo(lastTapX * (canvas.width / 800), lastTapY * (canvas.height / 600));
                                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                                ctx.lineWidth = 1 * (canvas.width / 800);
                                ctx.stroke();
                            }
                        }
                    }
                } catch (error) {
                    console.error('Coin draw error:', error);
                }
            }

            update() {
                try {
                    // Update shake timer and intensity
                    if (this.shakeIntensity > 0) {
                        this.shakeTimer++;
                        if (this.shakeTimer > 30) { // Shake for 30 frames (0.5 seconds at 60fps)
                            this.shakeIntensity = 0;
                            this.shakeTimer = 0;
                        }
                    }
                    
                    this.vy += (this.hasParachute && superParachuteTimer > 0) ? 0.01 : this.hasParachute ? 0.02 : 0.35; // Increased gravity for faster balls
                    if (this.hasParachute) {
                        this.vx += Math.sin(Date.now() / 100) * 0.05;
                    }
                    // Add random speed variations for chaos (increased frequency and intensity)
                    if (Math.random() < 0.15) { // More frequent speed variations
                        this.vx += (Math.random() - 0.5) * 3; // Higher intensity
                        this.vy += (Math.random() - 0.5) * 3;
                    }
                    
                    // Apply velocity damping to prevent erratic movement (reduced for faster gameplay)
                    this.vx *= 0.995; // Less damping for faster movement
                    this.vy *= 0.995;
                    
                    this.y += this.vy * (canvas.height / 600);
                    this.x += this.vx * (canvas.width / 800);

                    let logicalX = this.x / (canvas.width / 800);
                    const logicalY = this.y / (canvas.height / 600);
                    
                    // Parachute guidance - allow gentle steering when tapped
                    if (this.hasParachute && tapActive) {
                        const dx = lastTapX - logicalX;
                        const dy = lastTapY - logicalY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Only guide if tap is within reasonable distance
                        if (distance < 200) {
                            const guidanceStrength = 0.02; // Gentle guidance
                            this.vx += dx * guidanceStrength;
                            this.vy += dy * guidanceStrength * 0.5; // Less vertical guidance
                            
                            // Add visual feedback
                            if (Math.random() < 0.05) {
                                particles.push(new Particle(logicalX, logicalY, 'parachute'));
                            }
                        }
                    }

                    // Wrap around left and right boundaries
                    if (logicalX < 0) {
                        logicalX = 800;
                        this.x = logicalX * (canvas.width / 800);
                    } else if (logicalX > 800) {
                        logicalX = 0;
                        this.x = logicalX * (canvas.width / 800);
                    }

                    if (this.lastObstacleHitTime > 0) this.lastObstacleHitTime--;

                    if (this.vy > 0 && logicalY + this.radius / (canvas.height / 600) > pusher.y && 
                        logicalY - this.radius / (canvas.height / 600) < pusher.y + pusher.height &&
                        logicalX > pusher.x && logicalX < pusher.x + pusher.width) {
                        this.y = (pusher.y - this.radius / (canvas.height / 600)) * (canvas.height / 600);
                        this.vy = 0;
                        this.vx = pusher.speed * pusher.direction * 0.5 + (Math.random() * 8 + 4) * (Math.random() > 0.5 ? 1 : -1);
                        this.onPusher = true;
                        this.hasParachute = false;
                    } else if (this.onPusher && (logicalX < pusher.x || logicalX > pusher.x + pusher.width || logicalY > pusher.y + this.radius / (canvas.height / 600))) {
                        this.onPusher = false;
                    }

                    powerUps.forEach((powerUp, index) => {
                        if (logicalX > powerUp.x - powerUp.radius && logicalX < powerUp.x + powerUp.radius &&
                            logicalY > powerUp.y - powerUp.radius && logicalY < powerUp.y + powerUp.radius) {
                            if (powerUp.type === 'multiplier') {
                                multiplierTimer = 600;
                                playSound(660, 'sine', 0.5, 0.3);
                            } else if (powerUp.type === 'coinMagnet') {
                                coinMagnetTimer = 300;
                                playSound(440, 'triangle', 0.5, 0.3);
                            } else if (powerUp.type === 'extraCoin') {
                                coinCount += 5;
                                playSound(150, 'sawtooth', 0.8, 0.4); // Boom sound for extra balls
                            } else if (powerUp.type === 'superParachute') {
                                superParachuteTimer = 600;
                                playSound(330, 'triangle', 0.5, 0.3);
                            }
                            for (let i = 0; i < 5; i++) {
                                particles.push(new Particle(powerUp.x, powerUp.y, 'win'));
                            }
                            powerUps.splice(index, 1);
                        }
                    });

                    if (magnetActive && !this.onPusher) {
                        const winZoneCenter = bottomWinZone.x + bottomWinZone.width / 2;
                        const dx = winZoneCenter - logicalX;
                        this.vx += dx * 0.01;
                    }
                    if (coinMagnetTimer > 0 && !this.onPusher) {
                        const targets = [
                            { x: bottomWinZone.x + bottomWinZone.width / 2, y: edgeY },
                            { x: leftWinZone.x + leftWinZone.width / 2, y: leftWinZone.y + leftWinZone.height / 2 },
                            { x: rightWinZone.x + rightWinZone.width / 2, y: rightWinZone.y + rightWinZone.height / 2 }
                        ];
                        const nearest = targets.reduce((closest, target) => {
                            const dx = target.x - logicalX;
                            const dy = target.y - logicalY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            return distance < closest.distance ? { dx, dy, distance } : closest;
                        }, { dx: 0, dy: 0, distance: Infinity });
                        this.vx += nearest.dx * 0.01;
                        this.vy += nearest.dy * 0.01;
                    }

                    // Enhanced ball collision physics with flicker prevention
                    coins.forEach(other => {
                        if (other !== this) {
                            const otherLogicalX = other.x / (canvas.width / 800);
                            const otherLogicalY = other.y / (canvas.height / 600);
                            const dx = logicalX - otherLogicalX;
                            const dy = logicalY - otherLogicalY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const minDistance = (this.radius + other.radius) / (canvas.width / 800);
                            
                            // Performance optimization: only check nearby balls
                            if (distance > minDistance * 3) return;
                            
                            // Prevent multiple collisions in same frame
                            if (distance < minDistance && distance > 0 && !this.collisionProcessed && !other.collisionProcessed) {
                                // Mark both balls as processed this frame
                                this.collisionProcessed = true;
                                other.collisionProcessed = true;
                                
                                // Collision detected - calculate bounce physics
                                const angle = Math.atan2(dy, dx);
                                const sin = Math.sin(angle);
                                const cos = Math.cos(angle);
                                
                                // Rotate velocities
                                const vx1 = this.vx * cos + this.vy * sin;
                                const vy1 = this.vy * cos - this.vx * sin;
                                const vx2 = other.vx * cos + other.vy * sin;
                                const vy2 = other.vy * cos - other.vx * sin;
                                
                                // Elastic collision (conservation of momentum)
                                const newVx1 = vx2;
                                const newVx2 = vx1;
                                
                                // Rotate velocities back
                                this.vx = newVx1 * cos - vy1 * sin;
                                this.vy = vy1 * cos + newVx1 * sin;
                                other.vx = newVx2 * cos - vy2 * sin;
                                other.vy = vy2 * cos + newVx2 * sin;
                                
                                // Gentle separation to prevent sticking (reduced intensity)
                                const overlap = minDistance - distance;
                                const separationX = (overlap * dx) / distance;
                                const separationY = (overlap * dy) / distance;
                                
                                this.x += separationX * 0.3 * (canvas.width / 800);
                                this.y += separationY * 0.3 * (canvas.height / 600);
                                other.x -= separationX * 0.3 * (canvas.width / 800);
                                other.y -= separationY * 0.3 * (canvas.height / 600);
                                
                                // Add collision effects (reduced frequency)
                                if (Math.random() < 0.5) {
                                    particles.push(new Particle(logicalX, logicalY, 'spark'));
                                }
                                
                                // Removed ball collision sound
                                
                                // Add collision flash (shorter duration)
                                this.collisionFlashTime = 5;
                                other.collisionFlashTime = 5;
                                
                                // Trigger shake for both balls
                                this.shakeIntensity = 3;
                                this.shakeTimer = 0;
                                other.shakeIntensity = 3;
                                other.shakeTimer = 0;
                                
                                // Reduced randomness to prevent erratic movement
                                this.vx += (Math.random() - 0.5) * 3;
                                this.vy += (Math.random() - 0.5) * 3;
                                other.vx += (Math.random() - 0.5) * 3;
                                other.vy += (Math.random() - 0.5) * 3;
                            }
                        }
                    });

                    obstacles.forEach(obstacle => {
                        if (logicalX > obstacle.x && logicalX < obstacle.x + obstacle.width &&
                            logicalY + this.radius / (canvas.height / 600) > obstacle.y && logicalY - this.radius / (canvas.height / 600) < obstacle.y + obstacle.height) {
                            
                            // Different bounce effects based on obstacle type
                            if (obstacle.type === 'blue') {
                                // Blue obstacle: 2x bounce
                                this.vx += (Math.random() - 0.5) * 50; // 2x horizontal bounce
                                this.vy = -(Math.random() * 20 + 20); // 2x vertical bounce
                                for (let i = 0; i < 22; i++) {
                                    particles.push(new Particle(logicalX, logicalY, 'knockback'));
                                }
                                playSound(800, 'sine', 0.1, 0.3); // Different sound for blue obstacle
                                // Trigger strong shake for blue obstacle
                                this.shakeIntensity = 8;
                                this.shakeTimer = 0;
                            } else {
                                // Red obstacle: normal bounce
                                this.vx += (Math.random() - 0.5) * 25;
                                this.vy = -(Math.random() * 10 + 10);
                                for (let i = 0; i < 12; i++) {
                                    particles.push(new Particle(logicalX, logicalY, 'knockback'));
                                }
                                playSound(1200, 'sine', 0.05, 0.2); // Light tiny ping sound
                                // Trigger moderate shake for red obstacle
                                this.shakeIntensity = 4;
                                this.shakeTimer = 0;
                            }
                            
                            this.onPusher = false;
                            this.hasParachute = false;
                            this.lastObstacleHitTime = 30;
                            obstacle.flashTime = 10;
                        }
                    });

                    if (logicalY > edgeY && logicalX >= bottomWinZone.x && logicalX <= bottomWinZone.x + bottomWinZone.width) {
                        // Check if player controlled - bounce the ball
                        if (bottomWinZone.playerControlled) {
                            // Bounce the ball upward with some force
                            this.vy = -Math.abs(this.vy) - 5; // Bounce upward with extra force
                            this.vx += (Math.random() - 0.5) * 3; // Add slight horizontal variation
                            
                            // Create bounce effect particles
                            for (let i = 0; i < 5; i++) {
                                particles.push(new Particle(logicalX, edgeY, 'bounce'));
                            }
                            
                            // Play bounce sound
                            playSound(300, 'sine', 0.3, 0.2);
                            
                            console.log('Ball bounced off player-controlled bottom zone!');
                            return false; // Don't remove the ball, just bounce it
                        }
                        // Check if in repel mode
                        else if (bottomWinZone.repelMode) {
                            // Repel the ball down with force
                            this.vy = Math.abs(this.vy) + 15; // Strong downward force
                            this.vx += (Math.random() - 0.5) * 10; // Add some horizontal randomness
                            
                            // Create repel effect particles
                            for (let i = 0; i < 8; i++) {
                                particles.push(new Particle(logicalX, edgeY, 'repel'));
                            }
                            
                            // Play repel sound
                            playSound(200, 'sawtooth', 0.2, 0.3);
                            
                            console.log('Ball repelled by bottom win zone!');
                            return false; // Don't remove the ball, just repel it
                        } else {
                            // Normal win behavior
                            createWinExplosion(logicalX, edgeY);
                            let points = multiplierTimer > 0 ? 20 : 10;
                            // Bonus points for player-controlled zones
                            if (bottomWinZone.playerControlled) {
                                points *= 2;
                                // Extra particles for player control bonus
                                for (let i = 0; i < 5; i++) {
                                    particles.push(new Particle(logicalX, edgeY, 'bonus'));
                                }
                                console.log('Player-controlled zone bonus: +' + points + ' points!');
                            }
                            score += points;
                            consecutiveWins++;
                            bottomWinZone.glowTime = 20;
                            
                            // Random chance to activate repel mode (5% chance)
                            if (Math.random() < 0.05 && bottomWinZone.repelCooldown <= 0) {
                                bottomWinZone.repelMode = true;
                                bottomWinZone.repelTimer = 1200; // 20 seconds
                                bottomWinZone.repelCooldown = 3600; // 60 second cooldown
                                console.log('Bottom win zone entered repel mode for 20 seconds!');
                                
                                // Create repel mode activation effect
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(logicalX, edgeY, 'repel'));
                                }
                                playSound(150, 'square', 0.5, 0.4);
                            }
                        }
                        
                        // Track hit for dynamic sizing and direction change
                        const currentTime = Date.now();
                        if (currentTime - bottomWinZone.lastHitTime < 2000) { // Within 2 seconds
                            bottomWinZone.hitCount++;
                            bottomWinZone.fatTime = Math.min(bottomWinZone.fatTime + 60, 180); // Max 3 seconds fat time
                        } else {
                            bottomWinZone.hitCount = 1;
                            bottomWinZone.fatTime = 60;
                        }
                        bottomWinZone.lastHitTime = currentTime;
                        
                        // Change direction if hit threshold reached and cooldown is over
                        if (bottomWinZone.hitCount >= bottomWinZone.hitThreshold && bottomWinZone.directionChangeCooldown <= 0) {
                            bottomWinZone.direction *= -1; // Reverse direction
                            bottomWinZone.directionChangeCooldown = 180; // 3 second cooldown (60fps * 3)
                            bottomWinZone.hitCount = 0; // Reset hit count
                            console.log('Bottom win zone changed direction due to too many hits!');
                            
                            // Create direction change effect
                            for (let i = 0; i < 15; i++) {
                                particles.push(new Particle(bottomWinZone.x + bottomWinZone.width / 2, edgeY, 'direction'));
                            }
                            playSound(800, 'square', 0.3, 0.4); // Direction change sound
                        }
                        if (consecutiveWins >= 3) {
                            magnetActive = true;
                            magnetTimer = 300;
                            consecutiveWins = 0;
                            for (let i = 0; i < 10; i++) {
                                const particleX = bottomWinZone.x + Math.random() * bottomWinZone.width;
                                particles.push(new Particle(particleX, edgeY, 'magnet'));
                            }
                            playSound(330, 'square', 0.5);
                        }
                        playSound(432, 'sine', 1.0, 0.3);
                        return true;
                    } else if (logicalX >= leftWinZone.x && logicalX <= leftWinZone.x + leftWinZone.width &&
                    logicalY >= leftWinZone.y && logicalY <= leftWinZone.y + leftWinZone.height) {
                    console.log('Left win zone hit! Ball at:', logicalX, logicalY, 'Zone:', leftWinZone.x, leftWinZone.y, leftWinZone.width, leftWinZone.height, 'UFO present:', ufo && ufo.spawned);
                    
                    // Check if player controlled - bounce the ball
                    if (leftWinZone.playerControlled) {
                            // Bounce the ball away from the left wall
                            this.vx = Math.abs(this.vx) + 3; // Bounce rightward with extra force
                            this.vy += (Math.random() - 0.5) * 3; // Add slight vertical variation
                            
                            // Create bounce effect particles
                            for (let i = 0; i < 5; i++) {
                                particles.push(new Particle(leftWinZone.x + leftWinZone.width / 2, logicalY, 'bounce'));
                            }
                            
                            // Play bounce sound
                            playSound(300, 'sine', 0.3, 0.2);
                            
                            console.log('Ball bounced off player-controlled left zone!');
                            return false; // Don't remove the ball, just bounce it
                        }
                        // Check if in repel mode
                        else if (leftWinZone.repelMode) {
                            // Repel the ball down with force
                            this.vy = Math.abs(this.vy) + 15; // Strong downward force
                            this.vx += (Math.random() - 0.5) * 10; // Add some horizontal randomness
                            
                            // Create repel effect particles
                            for (let i = 0; i < 8; i++) {
                                particles.push(new Particle(leftWinZone.x + leftWinZone.width / 2, logicalY, 'repel'));
                            }
                            
                            // Play repel sound
                            playSound(200, 'sawtooth', 0.2, 0.3);
                            
                            console.log('Ball repelled by left win zone!');
                            return false; // Don't remove the ball, just repel it
                        } else {
                            // Normal win behavior
                            createWinExplosion(leftWinZone.x + leftWinZone.width / 2, logicalY);
                            let points = this.lastObstacleHitTime > 0 ? (multiplierTimer > 0 ? 40 : 20) : (multiplierTimer > 0 ? 20 : 10);
                            // Bonus points for player-controlled zones
                            if (leftWinZone.playerControlled) {
                                points *= 2;
                                // Extra particles for player control bonus
                                for (let i = 0; i < 5; i++) {
                                    particles.push(new Particle(leftWinZone.x + leftWinZone.width / 2, logicalY, 'bonus'));
                                }
                                console.log('Player-controlled zone bonus: +' + points + ' points!');
                            }
                            score += points;
                            consecutiveWins++;
                            leftWinZone.glowTime = 20;
                            
                            // Random chance to activate repel mode (5% chance)
                            if (Math.random() < 0.05 && leftWinZone.repelCooldown <= 0) {
                                leftWinZone.repelMode = true;
                                leftWinZone.repelTimer = 1200; // 20 seconds
                                leftWinZone.repelCooldown = 3600; // 60 second cooldown
                                console.log('Left win zone entered repel mode for 20 seconds!');
                                
                                // Create repel mode activation effect
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(leftWinZone.x + leftWinZone.width / 2, logicalY, 'repel'));
                                }
                                playSound(150, 'square', 0.5, 0.4);
                            }
                        }
                        
                        // Track hit for dynamic sizing and direction change
                        const currentTime = Date.now();
                        if (currentTime - leftWinZone.lastHitTime < 2000) { // Within 2 seconds
                            leftWinZone.hitCount++;
                            leftWinZone.fatTime = Math.min(leftWinZone.fatTime + 60, 180); // Max 3 seconds fat time
                        } else {
                            leftWinZone.hitCount = 1;
                            leftWinZone.fatTime = 60;
                        }
                        leftWinZone.lastHitTime = currentTime;
                        
                        // Change direction if hit threshold reached and cooldown is over
                        if (leftWinZone.hitCount >= leftWinZone.hitThreshold && leftWinZone.directionChangeCooldown <= 0) {
                            leftWinZone.direction *= -1; // Reverse direction
                            leftWinZone.directionChangeCooldown = 180; // 3 second cooldown (60fps * 3)
                            leftWinZone.hitCount = 0; // Reset hit count
                            console.log('Left win zone changed direction due to too many hits!');
                            
                            // Create direction change effect
                            for (let i = 0; i < 15; i++) {
                                particles.push(new Particle(leftWinZone.x + leftWinZone.width / 2, leftWinZone.y + leftWinZone.height / 2, 'direction'));
                            }
                            playSound(800, 'square', 0.3, 0.4); // Direction change sound
                        }
                        if (consecutiveWins >= 3) {
                            magnetActive = true;
                            magnetTimer = 300;
                            consecutiveWins = 0;
                            for (let i = 0; i < 10; i++) {
                                const particleX = bottomWinZone.x + Math.random() * bottomWinZone.width;
                                particles.push(new Particle(particleX, edgeY, 'magnet'));
                            }
                            playSound(330, 'square', 0.5);
                        }
                        playSound(432, 'sine', 1.0, 0.3);
                        return true;
                    } else if (logicalX >= rightWinZone.x && logicalX <= rightWinZone.x + rightWinZone.width &&
                    logicalY >= rightWinZone.y && logicalY <= rightWinZone.y + rightWinZone.height) {
                    console.log('Right win zone hit! Ball at:', logicalX, logicalY, 'Zone:', rightWinZone.x, rightWinZone.y, rightWinZone.width, rightWinZone.height, 'UFO present:', ufo && ufo.spawned);
                    
                    // Check if player controlled - bounce the ball
                    if (rightWinZone.playerControlled) {
                            // Bounce the ball away from the right wall
                            this.vx = -Math.abs(this.vx) - 3; // Bounce leftward with extra force
                            this.vy += (Math.random() - 0.5) * 3; // Add slight vertical variation
                            
                            // Create bounce effect particles
                            for (let i = 0; i < 5; i++) {
                                particles.push(new Particle(rightWinZone.x + rightWinZone.width / 2, logicalY, 'bounce'));
                            }
                            
                            // Play bounce sound
                            playSound(300, 'sine', 0.3, 0.2);
                            
                            console.log('Ball bounced off player-controlled right zone!');
                            return false; // Don't remove the ball, just bounce it
                        }
                        // Check if in repel mode
                        else if (rightWinZone.repelMode) {
                            // Repel the ball down with force
                            this.vy = Math.abs(this.vy) + 15; // Strong downward force
                            this.vx += (Math.random() - 0.5) * 10; // Add some horizontal randomness
                            
                            // Create repel effect particles
                            for (let i = 0; i < 8; i++) {
                                particles.push(new Particle(rightWinZone.x + rightWinZone.width / 2, logicalY, 'repel'));
                            }
                            
                            // Play repel sound
                            playSound(200, 'sawtooth', 0.2, 0.3);
                            
                            console.log('Ball repelled by right win zone!');
                            return false; // Don't remove the ball, just repel it
                        } else {
                            // Normal win behavior
                            createWinExplosion(rightWinZone.x + rightWinZone.width / 2, logicalY);
                            let points = this.lastObstacleHitTime > 0 ? (multiplierTimer > 0 ? 40 : 20) : (multiplierTimer > 0 ? 20 : 10);
                            // Bonus points for player-controlled zones
                            if (rightWinZone.playerControlled) {
                                points *= 2;
                                // Extra particles for player control bonus
                                for (let i = 0; i < 5; i++) {
                                    particles.push(new Particle(rightWinZone.x + rightWinZone.width / 2, logicalY, 'bonus'));
                                }
                                console.log('Player-controlled zone bonus: +' + points + ' points!');
                            }
                            score += points;
                            consecutiveWins++;
                            rightWinZone.glowTime = 20;
                            
                            // Random chance to activate repel mode (5% chance)
                            if (Math.random() < 0.05 && rightWinZone.repelCooldown <= 0) {
                                rightWinZone.repelMode = true;
                                rightWinZone.repelTimer = 1200; // 20 seconds
                                rightWinZone.repelCooldown = 3600; // 60 second cooldown
                                console.log('Right win zone entered repel mode for 20 seconds!');
                                
                                // Create repel mode activation effect
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(rightWinZone.x + rightWinZone.width / 2, logicalY, 'repel'));
                                }
                                playSound(150, 'square', 0.5, 0.4);
                            }
                        }
                        
                        // Track hit for dynamic sizing and direction change
                        const currentTime = Date.now();
                        if (currentTime - rightWinZone.lastHitTime < 2000) { // Within 2 seconds
                            rightWinZone.hitCount++;
                            rightWinZone.fatTime = Math.min(rightWinZone.fatTime + 60, 180); // Max 3 seconds fat time
                        } else {
                            rightWinZone.hitCount = 1;
                            rightWinZone.fatTime = 60;
                        }
                        rightWinZone.lastHitTime = currentTime;
                        
                        // Change direction if hit threshold reached and cooldown is over
                        if (rightWinZone.hitCount >= rightWinZone.hitThreshold && rightWinZone.directionChangeCooldown <= 0) {
                            rightWinZone.direction *= -1; // Reverse direction
                            rightWinZone.directionChangeCooldown = 180; // 3 second cooldown (60fps * 3)
                            rightWinZone.hitCount = 0; // Reset hit count
                            console.log('Right win zone changed direction due to too many hits!');
                            
                            // Create direction change effect
                            for (let i = 0; i < 15; i++) {
                                particles.push(new Particle(rightWinZone.x + rightWinZone.width / 2, rightWinZone.y + rightWinZone.height / 2, 'direction'));
                            }
                            playSound(800, 'square', 0.3, 0.4); // Direction change sound
                        }
                        if (consecutiveWins >= 3) {
                            magnetActive = true;
                            magnetTimer = 300;
                            consecutiveWins = 0;
                            for (let i = 0; i < 10; i++) {
                                const particleX = bottomWinZone.x + Math.random() * bottomWinZone.width;
                                particles.push(new Particle(particleX, edgeY, 'magnet'));
                            }
                            playSound(330, 'square', 0.5);
                        }
                        playSound(432, 'sine', 1.0, 0.3);
                        return true;
                    } else if (logicalY > edgeY) {
                        consecutiveWins = 0;
                        lostBalls++;
                        console.log('Ball lost off bottom:', lostBalls, 'Ball position:', logicalX, logicalY, 'UFO present:', ufo && ufo.spawned);
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.error('Coin update error:', error);
                    return false;
                }
            }
        }

        // Obstacle class
        class Obstacle {
            constructor() {
                try {
                    this.x = Math.random() * (800 - 50);
                    this.y = Math.random() * (400 - 200) + 200; // Random Y position between 200-400
                    this.width = 30;
                    this.height = 30;
                    this.vx = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 3 + 2); // Random speed 2-5
                    this.vy = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 2 + 1); // Random vertical speed 1-3
                    this.flashTime = 0;
                    this.type = 'red'; // Red obstacle type
                    this.directionChangeTimer = 0;
                    this.directionChangeInterval = Math.random() * 180 + 60; // Random direction change every 1-4 seconds
                } catch (error) {
                    console.error('Obstacle constructor error:', error);
                }
            }

            draw() {
                try {
                    if (this.flashTime > 0) {
                        ctx.fillStyle = `rgba(255, 0, 0, ${this.flashTime / 10})`;
                        ctx.fillRect(this.x * (canvas.width / 800), this.y * (canvas.height / 600), this.width * (canvas.width / 800), this.height * (canvas.height / 600));
                        this.flashTime--;
                    } else {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(this.x * (canvas.width / 800), this.y * (canvas.height / 600), this.width * (canvas.width / 800), this.height * (canvas.height / 600));
                    }
                } catch (error) {
                    console.error('Obstacle draw error:', error);
                }
            }

            update() {
                try {
                    // Update position
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Boundary checking with bounce
                    if (this.x < 0 || this.x + this.width > 800) {
                        this.vx *= -1;
                        // Add some randomness to speed when bouncing
                        this.vx *= (Math.random() * 0.4 + 0.8); // 80-120% of current speed
                    }
                    
                    if (this.y < 100 || this.y + this.height > 500) {
                        this.vy *= -1;
                        // Add some randomness to speed when bouncing
                        this.vy *= (Math.random() * 0.4 + 0.8); // 80-120% of current speed
                    }
                    
                    // Random direction changes
                    this.directionChangeTimer++;
                    if (this.directionChangeTimer >= this.directionChangeInterval) {
                        // Randomly change direction
                        if (Math.random() < 0.3) { // 30% chance to change horizontal direction
                            this.vx *= -1;
                        }
                        if (Math.random() < 0.3) { // 30% chance to change vertical direction
                            this.vy *= -1;
                        }
                        // Randomly adjust speed
                        this.vx *= (Math.random() * 0.6 + 0.7); // 70-130% of current speed
                        this.vy *= (Math.random() * 0.6 + 0.7); // 70-130% of current speed
                        
                        // Reset timer with new random interval
                        this.directionChangeTimer = 0;
                        this.directionChangeInterval = Math.random() * 180 + 60;
                    }
                    
                    // Keep speed within reasonable bounds
                    this.vx = Math.max(-6, Math.min(6, this.vx));
                    this.vy = Math.max(-4, Math.min(4, this.vy));
                    
                } catch (error) {
                    console.error('Obstacle update error:', error);
                }
            }
        }

        // Blue Obstacle class with 2x bounce
        class BlueObstacle {
            constructor() {
                try {
                    this.x = Math.random() * (800 - 50);
                    this.y = Math.random() * (400 - 200) + 200; // Random Y position between 200-400
                    this.width = 30;
                    this.height = 30;
                    this.vx = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 3 + 2); // Random speed 2-5
                    this.vy = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 2 + 1); // Random vertical speed 1-3
                    this.flashTime = 0;
                    this.type = 'blue'; // Blue obstacle type
                    this.directionChangeTimer = 0;
                    this.directionChangeInterval = Math.random() * 180 + 60; // Random direction change every 1-4 seconds
                } catch (error) {
                    console.error('BlueObstacle constructor error:', error);
                }
            }

            draw() {
                try {
                    if (this.flashTime > 0) {
                        ctx.fillStyle = `rgba(0, 0, 255, ${this.flashTime / 10})`;
                        ctx.fillRect(this.x * (canvas.width / 800), this.y * (canvas.height / 600), this.width * (canvas.width / 800), this.height * (canvas.height / 600));
                        this.flashTime--;
                    } else {
                        ctx.fillStyle = '#0066ff';
                        ctx.fillRect(this.x * (canvas.width / 800), this.y * (canvas.height / 600), this.width * (canvas.width / 800), this.height * (canvas.height / 600));
                    }
                } catch (error) {
                    console.error('BlueObstacle draw error:', error);
                }
            }

            update() {
                try {
                    // Update position
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Boundary checking with bounce
                    if (this.x < 0 || this.x + this.width > 800) {
                        this.vx *= -1;
                        // Add some randomness to speed when bouncing
                        this.vx *= (Math.random() * 0.4 + 0.8); // 80-120% of current speed
                    }
                    
                    if (this.y < 100 || this.y + this.height > 500) {
                        this.vy *= -1;
                        // Add some randomness to speed when bouncing
                        this.vy *= (Math.random() * 0.4 + 0.8); // 80-120% of current speed
                    }
                    
                    // Random direction changes
                    this.directionChangeTimer++;
                    if (this.directionChangeTimer >= this.directionChangeInterval) {
                        // Randomly change direction
                        if (Math.random() < 0.3) { // 30% chance to change horizontal direction
                            this.vx *= -1;
                        }
                        if (Math.random() < 0.3) { // 30% chance to change vertical direction
                            this.vy *= -1;
                        }
                        // Randomly adjust speed
                        this.vx *= (Math.random() * 0.6 + 0.7); // 70-130% of current speed
                        this.vy *= (Math.random() * 0.6 + 0.7); // 70-130% of current speed
                        
                        // Reset timer with new random interval
                        this.directionChangeTimer = 0;
                        this.directionChangeInterval = Math.random() * 180 + 60;
                    }
                    
                    // Keep speed within reasonable bounds
                    this.vx = Math.max(-6, Math.min(6, this.vx));
                    this.vy = Math.max(-4, Math.min(4, this.vy));
                    
                } catch (error) {
                    console.error('BlueObstacle update error:', error);
                }
            }
        }

        function createWinExplosion(x, y) {
            try {
                for (let i = 0; i < 45; i++) {
                    particles.push(new Particle(x, y, 'win'));
                }
                // Removed "Win!" text display - only particle explosion remains
            } catch (error) {
                console.error('Create win explosion error:', error);
            }
        }

        function handleInput(e) {
            try {
                if (gameOver || !gameStarted || gamePaused) return;
                e.preventDefault();
                initAudioContext();
                const rect = canvas.getBoundingClientRect();
                const x = (e.type === 'touchstart' ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.type === 'touchstart' ? e.touches[0].clientY : e.clientY) - rect.top;
                const scaledX = x * (800 / canvas.width);
                const scaledY = y * (600 / canvas.height);
                const currentTime = Date.now();
                const isDoubleTap = currentTime - lastTapTime < 300;
                lastTapTime = currentTime;
                
                // Store tap position for parachute guidance
                lastTapX = scaledX;
                lastTapY = scaledY;
                tapActive = true;

                // Check for win zone clicks - only bottom panel can be controlled
                const clickThreshold = 15; // Pixels threshold for clicking near zones
                
                // Check bottom win zone (horizontal line) - only controllable panel
                if (Math.abs(scaledY - edgeY) < clickThreshold && 
                    scaledX >= bottomWinZone.x && 
                    scaledX <= bottomWinZone.x + bottomWinZone.width) {
                    draggedZone = bottomWinZone;
                    dragStartY = scaledY;
                    dragStartZoneY = edgeY;
                    bottomWinZone.isDragging = true;
                    bottomWinZone.playerControlled = true;
                    bottomWinZone.speed = 0; // Stop automatic movement
                    console.log('Bottom win zone clicked for dragging');
                    return; // Don't spawn ball
                }

                if (ufo && ufo.spawned) {
                    const ufoX = ufo.x;
                    const ufoY = ufo.y;
                    const dx = ufoX - scaledX;
                    const dy = ufoY - scaledY;
                    if (Math.sqrt(dx * dx + dy * dy) < ufo.width / 2) {
                        coinCount += 25;
                        for (let i = 0; i < 10; i++) {
                            particles.push(new Particle(ufoX, ufoY, 'ufo'));
                        }
                        playSound(120, 'sawtooth', 1.0, 0.5); // Boom sound for UFO bonus
                        ufo = null;
                        console.log('UFO clicked: +25 balls');
                        return;
                    }
                }

                // Blue bomb click detection
                for (let i = 0; i < blueBombs.length; i++) {
                    const bomb = blueBombs[i];
                    const bombX = bomb.x;
                    const bombY = bomb.y;
                    const dx = bombX - scaledX;
                    const dy = bombY - scaledY;
                    if (Math.sqrt(dx * dx + dy * dy) < bomb.width / 2) {
                        coinCount = Math.max(0, coinCount - 25); // Lose 25 balls, minimum 0
                        for (let j = 0; j < 30; j++) {
                            particles.push(new Particle(bombX, bombY, 'explosion'));
                        }
                        playSound(100, 'sawtooth', 1.2, 0.6); // Explosion sound
                        blueBombs.splice(i, 1); // Remove the clicked bomb
                        console.log('Blue bomb clicked: -25 balls. Bombs remaining:', blueBombs.length);
                        return;
                    }
                }

                if (isDoubleTap) {
                    let jumped = false;
                    coins.forEach(coin => {
                        if (coin.onPusher && !jumped) {
                            const logicalCoinX = coin.x / (canvas.width / 800);
                            const logicalCoinY = coin.y / (canvas.height / 600);
                            const dx = logicalCoinX - scaledX;
                            const dy = logicalCoinY - scaledY;
                            if (Math.sqrt(dx * dx + dy * dy) < coin.radius / (canvas.width / 800) * 2.5) {
                                coin.vx = Math.random() > 0.5 ? (Math.random() * 20 + 20) : -(Math.random() * 20 + 20);
                                coin.vy = -(Math.random() * 10 + 8);
                                coin.onPusher = false;
                                jumped = true;
                                for (let i = 0; i < 5; i++) {
                                    particles.push(new Particle(scaledX, scaledY, 'win'));
                                }
                                playSound(600, 'sine', 0.2, 0.3);
                            }
                        }
                    });
                    if (jumped) return;
                }

                let parachuteAdded = false;
                coins.forEach(coin => {
                    if (!coin.hasParachute) {
                        const logicalCoinX = coin.x / (canvas.width / 800);
                        const logicalCoinY = coin.y / (canvas.height / 600);
                        const dx = logicalCoinX - scaledX;
                        const dy = logicalCoinY - scaledY;
                        if (Math.sqrt(dx * dx + dy * dy) < coin.radius / (canvas.width / 800) * 2.5) {
                            coin.hasParachute = true;
                            coin.flashTime = 10;
                            parachuteAdded = true;
                            parachuteFlashTime = 30;
                            for (let i = 0; i < 3; i++) {
                                particles.push(new Particle(scaledX, scaledY, 'win'));
                            }
                            playSound(440, 'sine', 0.2, 0.2);
                        }
                    }
                });
                if (!parachuteAdded && coinCount > 0) {
                    coins.push(new Coin(scaledX, 50));
                    coinCount--;
                    lastFireTime = Date.now(); // Track when player fires a ball
                    console.log('Ball dropped');
                } else if (!parachuteAdded) {
                    for (let i = 0; i < 3; i++) {
                        particles.push(new Particle(scaledX, scaledY, 'miss'));
                    }
                }
                if (coinCount <= 0 && !gameOver) {
                    gameOver = true;
                    displayHighScores();
                    canvas.removeEventListener('pointerdown', handleInput);
                }
                console.log('Input handled:', isDoubleTap ? 'Double-tap' : 'Single-tap');
            } catch (error) {
                console.error('Handle input error:', error);
            }
        }

        canvas.removeEventListener('touchstart', handleInput);
        canvas.removeEventListener('click', handleInput);
        canvas.addEventListener('pointerdown', handleInput);
        
        // Add pointer move and up events for dragging
        function handlePointerMove(e) {
            if (!draggedZone || draggedZone !== bottomWinZone) return; // Only handle bottom zone
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.type === 'touchmove' ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.type === 'touchmove' ? e.touches[0].clientY : e.clientY) - rect.top;
            const scaledX = x * (800 / canvas.width);
            const scaledY = y * (600 / canvas.height);
            
            const deltaX = scaledX - lastTapX;
            const deltaY = scaledY - dragStartY;
            
            // For bottom zone, allow both horizontal movement and width adjustment
            // Horizontal movement
            const newX = Math.max(50, Math.min(750 - draggedZone.width, bottomWinZone.x + deltaX * 0.5));
            draggedZone.x = newX;
            
            // Width adjustment based on vertical movement
            const newWidth = Math.max(50, Math.min(200, draggedZone.baseWidth + deltaY));
            draggedZone.width = newWidth;
        }
        
        function handlePointerUp(e) {
            if (draggedZone) {
                draggedZone.isDragging = false;
                // Restore automatic movement
                draggedZone.playerControlled = false;
                draggedZone.speed = draggedZone.originalSpeed;
                console.log('Win zone released - resuming automatic movement');
                draggedZone = null;
            }
        }
        
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerup', handlePointerUp);
        canvas.addEventListener('pointercancel', handlePointerUp);
        document.addEventListener('pointerup', handlePointerUp); // Handle mouse up outside canvas

        function gameLoop() {
            try {
                if (gameOver || !gameStarted) return;
                if (!ctx) {
                    console.error('Canvas context lost');
                    return;
                }
                
                // If game is paused, still request next frame but don't update
                if (gamePaused) {
                    requestAnimationFrame(gameLoop);
                    return;
                }
                
                // Frame rate limiting for tablets (improved to reduce flickering)
                if (isLowPerformance) {
                    const now = performance.now();
                    const frameDuration = 1000 / PERFORMANCE_SETTINGS.frameRate;
                    if (now - lastFrameTime < frameDuration) {
                        requestAnimationFrame(gameLoop);
                        return;
                    }
                    lastFrameTime = now;
                }
                
                // Anti-flicker canvas clearing
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Optimized background grid for performance
                if (PERFORMANCE_SETTINGS.enableComplexEffects) {
                    ctx.strokeStyle = 'rgba(128, 128, 128, 0.2)';
                    ctx.lineWidth = 1;
                    for (let i = -800; i < 800; i += PERFORMANCE_SETTINGS.backgroundGridDensity) {
                        ctx.beginPath();
                        ctx.moveTo(i * (canvas.width / 800), 0);
                        ctx.lineTo((i + 600) * (canvas.width / 800), canvas.height);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(i * (canvas.width / 800), canvas.height);
                        ctx.lineTo((i + 600) * (canvas.width / 800), 0);
                        ctx.stroke();
                    }
                }

                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#000000');
                gradient.addColorStop(1, '#1a0033');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (score >= lastScoreMilestone + 750) {
                    coinCount += 50;
                    lastScoreMilestone = Math.floor(score / 750) * 750;
                    bonusFlashTime = 60;
                    // Reduced bonus particles for tablets
                    const bonusParticleCount = isLowPerformance ? 5 : 15;
                    for (let i = 0; i < bonusParticleCount; i++) {
                        const particle = new Particle(canvas.width / 2 / (canvas.width / 800), 40, 'bonus');
                        if (particle) particles.push(particle);
                    }
                    playSound(100, 'sawtooth', 1.2, 0.6); // Boom sound for score milestone bonus
                    console.log('Awarded 50 balls at score:', lastScoreMilestone);
                }

                // Rocket landing at 1000 points
                if (score >= 1000 && !rocketLanded) {
                    rocketLanded = true;
                    rocket = new Rocket();
                    console.log('Rocket landing triggered at score 1000!');
                    playSound(300, 'sawtooth', 2.0, 0.5); // Rocket landing sound
                }

                // Auto-fire system - fire balls if player hasn't fired for 30 seconds
                const currentTime = Date.now();
                if (lastFireTime === 0) {
                    lastFireTime = currentTime; // Initialize on first frame
                } else if (currentTime - lastFireTime >= autoFireInterval) {
                    // Calculate how many balls to auto-fire (max 50 or current ball count, whichever is less)
                    const ballsToFire = Math.min(autoFireBallCount, coinCount);
                    
                    if (ballsToFire > 0) {
                        // Auto-fire the calculated number of balls
                        for (let i = 0; i < ballsToFire; i++) {
                            const randomX = Math.random() * 700 + 50; // Random position across screen
                            coins.push(new Coin(randomX, 50));
                            coinCount--;
                        }
                        lastFireTime = currentTime; // Reset timer
                        console.log(`Auto-fired ${ballsToFire} balls after 30 seconds of inactivity (player had ${coinCount + ballsToFire} balls)`);
                        
                        // Add visual feedback (reduced for tablets)
                        const autoFireParticleCount = isLowPerformance ? 8 : 20;
                        for (let i = 0; i < autoFireParticleCount; i++) {
                            const particle = new Particle(canvas.width / 2 / (canvas.width / 800), 40, 'bonus');
                            if (particle) particles.push(particle);
                        }
                        playSound(200, 'sawtooth', 0.5, 0.4); // Auto-fire sound
                    } else {
                        // No balls to fire, just reset timer
                        lastFireTime = currentTime;
                        console.log('Auto-fire triggered but player has no balls left');
                    }
                }

                ufoSpawnTimer++;
                if (ufoSpawnTimer >= 1200 && !ufo) { // Spawn every 20 seconds instead of 30
                    ufo = new UFO();
                    ufoSpawnTimer = 0;
                    console.log('UFO spawned');
                }

                if (ufo && ufo.spawned) {
                    ufo.update();
                    ufo.draw();
                    if (!ufo.spawned) ufo = null;
                }

                // Update and draw rocket
                if (rocket) {
                    if (!rocket.update()) {
                        rocket = null;
                    } else {
                        rocket.draw();
                    }
                }

                // Ball killer demon spawn logic
                ballKillerSpawnTimer++;
                if (ballKillerSpawnTimer >= ballKillerSpawnInterval && !ballKillerActive && lostBalls === coinCount && coinCount > 0) {
                    ballKiller = new BallKiller();
                    ballKillerActive = true;
                    ballKillerSpawnTimer = 0;
                    console.log('Ball killer demon spawned! Lost balls = Balls left');
                    
                    // Add spawn effect
                    for (let i = 0; i < 30; i++) {
                        particles.push(new Particle(ballKiller.x, ballKiller.y, 'demon'));
                    }
                    playSound(150, 'sawtooth', 1.0, 0.6); // Demon spawn sound
                }

                // Update and draw ball killer
                if (ballKiller && ballKillerActive) {
                    if (!ballKiller.update()) {
                        ballKiller = null;
                    } else {
                        ballKiller.draw();
                    }
                }

                // Blue bomb spawn logic
                blueBombSpawnTimer++;
                if (blueBombSpawnTimer >= blueBombSpawnInterval && blueBombs.length < maxBlueBombs) {
                    const newBomb = new BlueBomb();
                    blueBombs.push(newBomb);
                    blueBombSpawnTimer = 0;
                    console.log('Blue bomb spawned! Total bombs:', blueBombs.length, 'Position:', newBomb.x, newBomb.y);
                    
                    // Add spawn effect
                    for (let i = 0; i < 20; i++) {
                        particles.push(new Particle(newBomb.x, newBomb.y, 'bomb'));
                    }
                    playSound(200, 'sawtooth', 0.8, 0.4); // Bomb spawn sound
                }
                
                // Debug: Log bomb status every 5 seconds
                if (blueBombSpawnTimer % 300 === 0) {
                    console.log('Bomb debug - Timer:', blueBombSpawnTimer, 'Bombs:', blueBombs.length, 'Max:', maxBlueBombs);
                }

                // Update and draw blue bombs
                blueBombs = blueBombs.filter(bomb => {
                    if (bomb.update()) {
                        bomb.draw();
                        return true;
                    } else {
                        console.log('Blue bomb exploded naturally');
                        return false;
                    }
                });

                resizeTimer++;
                if (resizeTimer >= resizeInterval) {
                    bottomWinZone.width = Math.floor(Math.random() * (150 - 50 + 1)) + 50;
                    leftWinZone.width = Math.floor(Math.random() * (75 - 25 + 1)) + 25;
                    leftWinZone.height = Math.floor(Math.random() * (150 - 50 + 1)) + 50;
                    rightWinZone.width = Math.floor(Math.random() * (75 - 25 + 1)) + 25;
                    rightWinZone.height = Math.floor(Math.random() * (150 - 50 + 1)) + 50;
                    if (bottomWinZone.x + bottomWinZone.width > 800) {
                        bottomWinZone.x = 800 - bottomWinZone.width;
                    }
                    if (bottomWinZone.x < 0) {
                        bottomWinZone.x = 0;
                    }
                    resizeTimer = 0;
                    resizeInterval = Math.floor(Math.random() * (216 - 108 + 1)) + 108;
                    console.log('Win zones resized');
                }

                if (Math.random() < 0.01 && powerUps.length < 3) powerUps.push(new PowerUp());
                powerUps.forEach(powerUp => {
                    powerUp.update();
                    powerUp.draw();
                });
                if (multiplierTimer > 0) multiplierTimer--;
                if (coinMagnetTimer > 0) coinMagnetTimer--;
                if (superParachuteTimer > 0) superParachuteTimer--;

                if (coinCount <= 0) {
                    pusher.width = 0;
                    pusher.speed = 0;
                }

                if (pusher.width > 0) {
                    ctx.fillStyle = '#8b0000';
                    ctx.fillRect(pusher.x * (canvas.width / 800), pusher.y * (canvas.height / 600), pusher.width * (canvas.width / 800), pusher.height * (canvas.height / 600));
                }

                // Pusher movement with improved boundary checking
                pusher.x += pusher.speed * pusher.direction;
                if (pusher.x + pusher.width > 800 - 50) {
                    pusher.x = 800 - 50 - pusher.width;
                    pusher.direction = -1;
                } else if (pusher.x < 50) {
                    pusher.x = 50;
                    pusher.direction = 1;
                }

                // Bottom win zone movement with improved boundary checking
                if (!bottomWinZone.playerControlled) {
                    bottomWinZone.x += bottomWinZone.speed * bottomWinZone.direction;
                    if (bottomWinZone.x + bottomWinZone.width > 800 - 50) {
                        bottomWinZone.x = 800 - 50 - bottomWinZone.width;
                        bottomWinZone.direction = -1;
                    } else if (bottomWinZone.x < 50) {
                        bottomWinZone.x = 50;
                        bottomWinZone.direction = 1;
                    }
                }
                
                // Update direction change cooldown
                if (bottomWinZone.directionChangeCooldown > 0) {
                    bottomWinZone.directionChangeCooldown--;
                }
                
                // Update repel mode timers
                if (bottomWinZone.repelTimer > 0) {
                    bottomWinZone.repelTimer--;
                    if (bottomWinZone.repelTimer <= 0) {
                        bottomWinZone.repelMode = false;
                        console.log('Bottom win zone repel mode ended');
                    }
                }
                if (bottomWinZone.repelCooldown > 0) {
                    bottomWinZone.repelCooldown--;
                }

                // Left win zone movement with improved boundary checking
                if (!leftWinZone.playerControlled) {
                    leftWinZone.y += leftWinZone.speed * leftWinZone.direction;
                    if (leftWinZone.y + leftWinZone.height > 500) {
                        leftWinZone.y = 500 - leftWinZone.height;
                        leftWinZone.direction = -1;
                    } else if (leftWinZone.y < 100) {
                        leftWinZone.y = 100;
                        leftWinZone.direction = 1;
                    }
                }
                
                // Update direction change cooldown
                if (leftWinZone.directionChangeCooldown > 0) {
                    leftWinZone.directionChangeCooldown--;
                }
                
                // Update repel mode timers
                if (leftWinZone.repelTimer > 0) {
                    leftWinZone.repelTimer--;
                    if (leftWinZone.repelTimer <= 0) {
                        leftWinZone.repelMode = false;
                        console.log('Left win zone repel mode ended');
                    }
                }
                if (leftWinZone.repelCooldown > 0) {
                    leftWinZone.repelCooldown--;
                }

                // Right win zone movement with improved boundary checking
                if (!rightWinZone.playerControlled) {
                    rightWinZone.y += rightWinZone.speed * rightWinZone.direction;
                    if (rightWinZone.y + rightWinZone.height > 500) {
                        rightWinZone.y = 500 - rightWinZone.height;
                        rightWinZone.direction = -1;
                    } else if (rightWinZone.y < 100) {
                        rightWinZone.y = 100;
                        rightWinZone.direction = 1;
                    }
                }
                
                // Update direction change cooldown
                if (rightWinZone.directionChangeCooldown > 0) {
                    rightWinZone.directionChangeCooldown--;
                }
                
                // Update repel mode timers
                if (rightWinZone.repelTimer > 0) {
                    rightWinZone.repelTimer--;
                    if (rightWinZone.repelTimer <= 0) {
                        rightWinZone.repelMode = false;
                        console.log('Right win zone repel mode ended');
                    }
                }
                if (rightWinZone.repelCooldown > 0) {
                    rightWinZone.repelCooldown--;
                }

                if (magnetActive) {
                    magnetTimer--;
                    if (magnetTimer <= 0) magnetActive = false;
                    if (Math.random() < 0.1 && particles.length < 100) {
                        const particleX = bottomWinZone.x + Math.random() * bottomWinZone.width;
                        particles.push(new Particle(particleX, edgeY, 'magnet'));
                    }
                }

                // Reset collision processed flags
                coins.forEach(coin => coin.collisionProcessed = false);
                
                coins = coins.filter(coin => !coin.update());
                coins.forEach(coin => coin.draw());

                particles = particles.filter(particle => !particle.update()).slice(-100);
                particles.forEach(particle => particle.draw());

                if (Math.random() < 0.01 && obstacles.length < 3) {
                                    // Randomly choose between red and blue obstacles
                if (Math.random() < 0.5) { // 50% chance for blue obstacle (increased from 30%)
                    obstacles.push(new BlueObstacle());
                } else {
                    obstacles.push(new Obstacle());
                }
                }
                obstacles.forEach(obstacle => {
                    obstacle.update();
                    obstacle.draw();
                });

                // Regular score display
                scoreDisplay.textContent = `Score: ${score}`;
                ballsLeftDisplay.textContent = `Balls Left: ${coinCount}`;
                lostBallsDisplay.textContent = `Lost Balls: ${lostBalls}`;
                if (coinCount <= 15) {
                    ballsLeftDisplay.classList.add('low-balls');
                } else {
                    ballsLeftDisplay.classList.remove('low-balls');
                }
                if (bonusFlashTime > 0) {
                    ctx.font = `${24 * (canvas.width / 800)}px 'Orbitron', sans-serif`;
                    ctx.fillStyle = `rgba(255, 255, 0, ${Math.max(0.4, bonusFlashTime / 60)})`; // Minimum opacity to reduce flicker
                    ctx.fillText('+50 Balls!', canvas.width / 2, 20 * (canvas.height / 600));
                    bonusFlashTime--;
                }
                if (parachuteFlashTime > 0) {
                    ctx.font = `${20 * (canvas.width / 800)}px 'Orbitron', sans-serif`;
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.max(0.4, parachuteFlashTime / 30)})`; // Minimum opacity to reduce flicker
                    ctx.fillText('Parachute Active!', canvas.width / 2, 130 * (canvas.height / 600));
                    parachuteFlashTime--;
                }
                ctx.shadowBlur = 0;
                let textY = 160;
                if (magnetActive) {
                    const scale = 1 + Math.sin(magnetTimer / 20) * 0.05; // Reduced scaling frequency and intensity
                    ctx.font = `${24 * scale * (canvas.width / 800)}px 'Orbitron', sans-serif`;
                    ctx.fillStyle = `rgba(0, 255, 204, ${Math.max(0.3, magnetTimer / 300)})`; // Minimum opacity to reduce flicker
                    ctx.fillText('Magnet Active!', canvas.width / 2, textY * (canvas.height / 600));
                    textY += 30;
                }
                if (multiplierTimer > 0) {
                    ctx.font = `${20 * (canvas.width / 800)}px 'Orbitron', sans-serif`;
                    ctx.fillStyle = `rgba(255, 0, 0, ${Math.max(0.3, multiplierTimer / 600)})`; // Minimum opacity to reduce flicker
                    ctx.fillText('2x Multiplier!', canvas.width / 2, textY * (canvas.height / 600));
                    textY += 30;
                }
                if (coinMagnetTimer > 0) {
                    ctx.font = `${20 * (canvas.width / 800)}px 'Orbitron', sans-serif`;
                    ctx.fillStyle = `rgba(0, 183, 235, ${Math.max(0.3, coinMagnetTimer / 300)})`; // Minimum opacity to reduce flicker
                    ctx.fillText('Coin Magnet!', canvas.width / 2, textY * (canvas.height / 600));
                    textY += 30;
                }
                if (superParachuteTimer > 0) {
                    ctx.font = `${20 * (canvas.width / 800)}px 'Orbitron', sans-serif`;
                    ctx.fillStyle = `rgba(0, 255, 204, ${Math.max(0.3, superParachuteTimer / 600)})`; // Minimum opacity to reduce flicker
                    ctx.fillText('Super Parachute!', canvas.width / 2, textY * (canvas.height / 600));
                }

                // Dynamic win zone sizing based on hits
                // Bottom win zone
                if (bottomWinZone.fatTime > 0) {
                    // Calculate expansion based on hit count
                    const expansionPercent = bottomWinZone.hitCount * 10; // 10% per hit
                    
                    // If expansion reaches 75%, reset to 10% and start over
                    if (expansionPercent >= 75) {
                        bottomWinZone.hitCount = 1; // Reset to 1 hit (10% expansion)
                        const fatMultiplier = 1 + (bottomWinZone.hitCount * 0.1); // 10% expansion
                        bottomWinZone.width = bottomWinZone.baseWidth * fatMultiplier;
                    } else {
                        // Normal expansion up to 75%
                        const fatMultiplier = 1 + (expansionPercent / 100);
                        bottomWinZone.width = bottomWinZone.baseWidth * fatMultiplier;
                    }
                    bottomWinZone.fatTime--;
                } else {
                    bottomWinZone.width = bottomWinZone.baseWidth;
                }
                
                // Left win zone
                if (leftWinZone.fatTime > 0) {
                    const fatMultiplier = 1 + (leftWinZone.hitCount * 0.1); // Reduced to 10% wider per hit
                    leftWinZone.width = leftWinZone.baseWidth * fatMultiplier;
                    leftWinZone.fatTime--;
                } else {
                    leftWinZone.width = leftWinZone.baseWidth;
                }
                
                // Right win zone
                if (rightWinZone.fatTime > 0) {
                    const fatMultiplier = 1 + (rightWinZone.hitCount * 0.1); // Reduced to 10% wider per hit
                    rightWinZone.width = rightWinZone.baseWidth * fatMultiplier;
                    rightWinZone.fatTime--;
                } else {
                    rightWinZone.width = rightWinZone.baseWidth;
                }

                if (bottomWinZone.glowTime > 0) {
                    ctx.strokeStyle = `rgba(0, 255, 204, ${bottomWinZone.glowTime / 20})`;
                    ctx.shadowColor = '#00ccff';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 10 * (canvas.width / 800);
                    ctx.beginPath();
                    ctx.moveTo(bottomWinZone.x * (canvas.width / 800), edgeY * (canvas.height / 600));
                    ctx.lineTo((bottomWinZone.x + bottomWinZone.width) * (canvas.width / 800), edgeY * (canvas.height / 600));
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    bottomWinZone.glowTime--;
                }
                // Draw bottom win zone with repel mode indicator
                if (bottomWinZone.repelMode) {
                    ctx.strokeStyle = '#ff8800'; // Orange color for repel mode
                    ctx.shadowColor = '#ff8800';
                    ctx.shadowBlur = 10;
                } else if (bottomWinZone.playerControlled) {
                    ctx.strokeStyle = '#00ff00'; // Green color for player-controlled
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 15;
                } else {
                    ctx.strokeStyle = '#ffd700'; // Gold color for normal mode
                    ctx.shadowBlur = 0;
                }
                ctx.lineWidth = 5 * (canvas.width / 800);
                ctx.beginPath();
                ctx.moveTo(bottomWinZone.x * (canvas.width / 800), edgeY * (canvas.height / 600));
                ctx.lineTo((bottomWinZone.x + bottomWinZone.width) * (canvas.width / 800), edgeY * (canvas.height / 600));
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Draw static shock effects when magnet is active
                if (magnetActive) {
                    const shockCount = 8; // Number of static shocks
                    const shockLength = 20 * (canvas.width / 800); // Length of each shock
                    const shockSpacing = bottomWinZone.width / shockCount; // Space between shocks
                    
                    ctx.strokeStyle = '#00ffff'; // Cyan color for static shocks
                    ctx.lineWidth = 2 * (canvas.width / 800);
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 8;
                    
                    for (let i = 0; i < shockCount; i++) {
                        const shockX = bottomWinZone.x + (i * shockSpacing) + (Math.random() * shockSpacing * 0.5);
                        const shockY = edgeY + (Math.random() * 10 - 5) * (canvas.height / 600); // Random vertical offset
                        
                        // Create zigzag static shock pattern
                        ctx.beginPath();
                        ctx.moveTo(shockX * (canvas.width / 800), shockY * (canvas.height / 600));
                        
                        let currentX = shockX;
                        let currentY = shockY;
                        const segments = 5; // Number of zigzag segments
                        
                        for (let j = 0; j < segments; j++) {
                            const segmentLength = shockLength / segments;
                            const angle = (Math.random() * 60 - 30) * Math.PI / 180; // Random angle between -30 and 30 degrees
                            
                            currentX += Math.cos(angle) * segmentLength;
                            currentY += Math.sin(angle) * segmentLength;
                            
                            ctx.lineTo(currentX * (canvas.width / 800), currentY * (canvas.height / 600));
                        }
                        
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                }

                if (leftWinZone.glowTime > 0) {
                    ctx.strokeStyle = `rgba(0, 255, 204, ${leftWinZone.glowTime / 20})`;
                    ctx.shadowColor = '#00ccff';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 10 * (canvas.width / 800);
                    ctx.beginPath();
                    ctx.moveTo(leftWinZone.x * (canvas.width / 800), leftWinZone.y * (canvas.height / 600));
                    ctx.lineTo(leftWinZone.x * (canvas.width / 800), (leftWinZone.y + leftWinZone.height) * (canvas.height / 600));
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    leftWinZone.glowTime--;
                }
                // Draw left win zone with repel mode indicator
                if (leftWinZone.repelMode) {
                    ctx.strokeStyle = '#ff8800'; // Orange color for repel mode
                    ctx.shadowColor = '#ff8800';
                    ctx.shadowBlur = 10;
                } else if (leftWinZone.playerControlled) {
                    ctx.strokeStyle = '#00ff00'; // Green color for player-controlled
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 15;
                } else {
                    ctx.strokeStyle = '#ffd700'; // Gold color for normal mode
                    ctx.shadowBlur = 0;
                }
                ctx.lineWidth = 5 * (canvas.width / 800);
                ctx.beginPath();
                ctx.moveTo(leftWinZone.x * (canvas.width / 800), leftWinZone.y * (canvas.height / 600));
                ctx.lineTo(leftWinZone.x * (canvas.width / 800), (leftWinZone.y + leftWinZone.height) * (canvas.height / 600));
                ctx.stroke();
                ctx.shadowBlur = 0;

                if (rightWinZone.glowTime > 0) {
                    ctx.strokeStyle = `rgba(0, 255, 204, ${rightWinZone.glowTime / 20})`;
                    ctx.shadowColor = '#00ccff';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 10 * (canvas.width / 800);
                    ctx.beginPath();
                    ctx.moveTo(rightWinZone.x * (canvas.width / 800), rightWinZone.y * (canvas.height / 600));
                    ctx.lineTo(rightWinZone.x * (canvas.width / 800), (rightWinZone.y + rightWinZone.height) * (canvas.height / 600));
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    rightWinZone.glowTime--;
                }
                // Draw right win zone with repel mode indicator
                if (rightWinZone.repelMode) {
                    ctx.strokeStyle = '#ff8800'; // Orange color for repel mode
                    ctx.shadowColor = '#ff8800';
                    ctx.shadowBlur = 10;
                } else if (rightWinZone.playerControlled) {
                    ctx.strokeStyle = '#00ff00'; // Green color for player-controlled
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 15;
                } else {
                    ctx.strokeStyle = '#ffd700'; // Gold color for normal mode
                    ctx.shadowBlur = 0;
                }
                ctx.lineWidth = 5 * (canvas.width / 800);
                ctx.beginPath();
                ctx.moveTo(rightWinZone.x * (canvas.width / 800), rightWinZone.y * (canvas.height / 600));
                ctx.lineTo(rightWinZone.x * (canvas.width / 800), (rightWinZone.y + rightWinZone.height) * (canvas.height / 600));
                ctx.stroke();
                ctx.shadowBlur = 0;


                
                // Reset tap active flag after a short delay for parachute guidance
                if (tapActive) {
                    setTimeout(() => {
                        tapActive = false;
                    }, 100); // Keep active for 100ms for responsive guidance
                }

                ctx.restore();
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Game loop error:', error);
            }
        }

        // Don't start game loop automatically - wait for user to click start
        // gameLoop(); // Removed - game loop starts when user clicks start button
    </script>
    
    <!-- Footer with Franksgames 2025 -->
    <div id="franksgamesLogo" class="footer-text" style="
        position: fixed;
        bottom: 2px;
        left: 75%;
        transform: translateX(-50%);
        font-family: 'Orbitron', sans-serif;
        font-size: 12px;
        font-weight: bold;
        color: #ffffff;
        text-align: center;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 8px;
        border-radius: 3px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
        overflow: hidden;
    ">
        Franksgames 2025
    </div>
</body>
</html>