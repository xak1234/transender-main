<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hellspin 666 V4 Pusher Combo Mode</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            background: #111; 
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex; 
            justify-content: center; 
            align-items: center; 
        }
        
        canvas { 
            border: 2px solid #ff4500; 
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.5); 
            max-width: 95vw; 
            max-height: 95vh; 
            width: auto; 
            height: auto; 
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Audio context (initialized on first input)
        let audioCtx = null;
        function initAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            }
        }

        function playSound(frequency, type, duration, volume = 0.5) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // Responsive canvas size
        function resizeCanvas() {
            const aspectRatio = 800 / 600;
            const maxWidth = Math.min(window.innerWidth * 0.85, 900);
            const maxHeight = Math.min(window.innerHeight * 0.85, 600);
            let width = maxWidth;
            let height = width / aspectRatio;
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game objects
        let coins = [];
        let particles = [];
        let obstacles = [];
        const pusher = { x: 250, y: 100, width: 300, height: 50, speed: 4, direction: 1 };
        const edgeY = 500;
        const winZone = { x: 350, width: 100, speed: 1, direction: 1, glowTime: 0 };
        let score = 0;
        let coinCount = 100;
        let consecutiveWins = 0;
        let magnetActive = false;
        let magnetTimer = 0;

        // Particle class for effects
        class Particle {
            constructor(x, y, type) {
                this.x = x * canvas.width / 800;
                this.y = y * canvas.height / 600;
                this.size = (type === 'spark' || type === 'parachute' || type === 'magnet' || type === 'miss' ? Math.random() * 2 + 1 : Math.random() * 5 + 2) * (canvas.width / 800);
                this.vx = (type === 'spark' || type === 'parachute' || type === 'magnet' || type === 'miss') ? (Math.random() - 0.5) * 4 : (Math.random() - 0.5) * 8;
                this.vy = (type === 'spark' || type === 'parachute' || type === 'magnet' || type === 'miss') ? (Math.random() - 0.5) * 4 : (Math.random() - 0.5) * 8;
                this.life = type === 'spark' || type === 'parachute' || type === 'magnet' || type === 'miss' ? 15 : 30;
                this.color = type === 'spark' || type === 'parachute' ? '#ffffff' : type === 'knockback' ? '#ffa500' : type === 'magnet' ? '#00b7eb' : type === 'miss' ? '#ffff00' : `hsl(${Math.random() * 360}, 100%, 50%)`;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }

            update() {
                this.x += this.vx * (canvas.width / 800);
                this.y += this.vy * (canvas.height / 600);
                this.vy += 0.1;
                this.size *= 0.95;
                this.life--;
                return this.life <= 0;
            }
        }

        // Coin class
        class Coin {
            constructor(x, y) {
                this.x = x * canvas.width / 800;
                this.y = y * canvas.height / 600;
                this.radius = 15 * (canvas.width / 800);
                this.vy = 0;
                this.vx = 0;
                this.onPusher = false;
                this.glowTime = 0;
                this.hasParachute = false;
                this.flashTime = 0;
                playSound(440, 'sine', 0.1);
                for (let i = 0; i < 5; i++) {
                    particles.push(new Particle(x, y, 'miss'));
                }
            }

            draw() {
                if (this.flashTime > 0) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.flashTime / 10})`;
                    ctx.fill();
                    this.flashTime--;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(this.x - 5 * (canvas.width / 800), this.y - 5 * (canvas.height / 600), 2 * (canvas.width / 800), this.x, this.y, this.radius);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(1, '#8b0000');
                ctx.fillStyle = gradient;
                ctx.shadowColor = this.glowTime > 0 ? '#ff0000' : '#ff0000';
                ctx.shadowBlur = this.glowTime > 0 ? 20 : 10;
                ctx.fill();
                ctx.shadowBlur = 0;
                if (this.glowTime > 0) this.glowTime--;

                if (this.hasParachute) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - this.radius - 5 * (canvas.height / 600), this.radius, Math.PI, 0);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2 * (canvas.width / 800);
                    ctx.stroke();
                    if (Math.random() < 0.2) {
                        particles.push(new Particle(this.x / (canvas.width / 800), this.y / (canvas.height / 600) + this.radius / (canvas.height / 600), 'parachute'));
                    }
                }
            }

            update() {
                this.vy += this.hasParachute ? 0.02 : 0.2;
                this.y += this.vy * (canvas.height / 600);
                this.x += this.vx * (canvas.width / 800);

                if (magnetActive && !this.onPusher) {
                    const winZoneCenter = winZone.x + winZone.width / 2;
                    const dx = winZoneCenter - this.x / (canvas.width / 800);
                    this.vx += dx * 0.01;
                }

                if (this.y + this.radius > pusher.y && this.y - this.radius < pusher.y + pusher.height &&
                    this.x > pusher.x && this.x < pusher.x + pusher.width) {
                    if (!this.onPusher || this.y > pusher.y - this.radius + 5) {
                        this.y = pusher.y - this.radius;
                        this.vy = 0;
                        this.vx = pusher.speed * pusher.direction * 0.5;
                        this.onPusher = true;
                        this.hasParachute = false;
                    }
                } else if (this.onPusher && this.y > pusher.y + this.radius) {
                    this.onPusher = false;
                }

                if (this.onPusher && (this.x < pusher.x || this.x > pusher.x + pusher.width)) {
                    this.onPusher = false;
                }

                let coinsOnPusher = coins.filter(c => c.onPusher && c !== this).length;
                if (coinsOnPusher > 3) {
                    this.vx += (Math.random() - 0.5) * 8;
                    this.glowTime = 10;
                }

                coins.forEach(other => {
                    if (other !== this && this.onPusher && other.onPusher) {
                        let dx = this.x - other.x;
                        let dy = this.y - other.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < this.radius * 2 && distance > 0) {
                            let force = (this.radius * 2 - distance) * 0.05;
                            this.vx += (dx / distance) * force;
                            other.vx -= (dx / distance) * force;
                            particles.push(new Particle(this.x / (canvas.width / 800), this.y / (canvas.height / 600), 'spark'));
                        }
                    }
                });

                obstacles.forEach(obstacle => {
                    if (this.x > obstacle.x && this.x < obstacle.x + obstacle.width &&
                        this.y + this.radius > obstacle.y && this.y - this.radius < obstacle.y + obstacle.height) {
                        this.vx += (Math.random() - 0.5) * 15;
                        this.vy = -7;
                        this.onPusher = false;
                        this.hasParachute = false;
                        for (let i = 0; i < 8; i++) {
                            particles.push(new Particle(this.x / (canvas.width / 800), this.y / (canvas.height / 600), 'knockback'));
                        }
                        obstacle.flashTime = 10;
                        playSound(110, 'square', 0.2);
                    }
                });

                // Fix win zone collision check
                const logicalX = this.x / (canvas.width / 800);
                const logicalY = this.y / (canvas.height / 600);
                if (logicalY > edgeY && logicalX >= winZone.x && logicalX <= winZone.x + winZone.width) {
                    createWinExplosion(this.x / (canvas.width / 800), edgeY);
                    score += 10;
                    consecutiveWins++;
                    winZone.glowTime = 20;
                    if (consecutiveWins >= 3) {
                        magnetActive = true;
                        magnetTimer = 300;
                        consecutiveWins = 0;
                        for (let i = 0; i < 10; i++) {
                            const particleX = winZone.x + Math.random() * winZone.width;
                            particles.push(new Particle(particleX, edgeY, 'magnet'));
                        }
                        playSound(330, 'square', 0.5);
                    }
                    playSound(880, 'sine', 0.5);
                    return true;
                } else if (logicalY > edgeY) {
                    consecutiveWins = 0;
                    return true;
                }
                return false;
            }
        }

        // Obstacle class
        class Obstacle {
            constructor() {
                this.x = Math.random() * (800 - 50);
                this.y = 300;
                this.width = 30;
                this.height = 30;
                this.vx = (Math.random() > 0.5 ? 1 : -1) * 3;
                this.flashTime = 0;
            }

            draw() {
                if (this.flashTime > 0) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${this.flashTime / 10})`;
                    ctx.fillRect(this.x * (canvas.width / 800), this.y * (canvas.height / 600), this.width * (canvas.width / 800), this.height * (canvas.height / 600));
                    this.flashTime--;
                } else {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x * (canvas.width / 800), this.y * (canvas.height / 600), this.width * (canvas.width / 800), this.height * (canvas.height / 600));
                }
            }

            update() {
                this.x += this.vx;
                if (this.x < 0 || this.x + this.width > 800) {
                    this.vx *= -1;
                }
            }
        }

        function createWinExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                particles.push(new Particle(x, y, 'win'));
            }
            let flashTime = 60;
            let flash = () => {
                ctx.font = `${20 * (canvas.width / 800)}px Arial`;
                ctx.fillStyle = `rgba(255, 215, 0, ${flashTime / 60})`;
                ctx.textAlign = 'center';
                ctx.fillText('Win!', x * (canvas.width / 800), y * (canvas.height / 600) - 30 * (canvas.height / 600));
                flashTime--;
                if (flashTime > 0) requestAnimationFrame(flash);
            };
            requestAnimationFrame(flash);
        }

        function handleInput(e) {
            e.preventDefault();
            initAudioContext();
            const rect = canvas.getBoundingClientRect();
            const x = (e.type === 'touchstart' ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.type === 'touchstart' ? e.touches[0].clientY : e.clientY) - rect.top;
            const scaledX = x * (800 / canvas.width);
            const scaledY = y * (600 / canvas.height);
            let parachuteAdded = false;
            coins.forEach(coin => {
                if (!coin.hasParachute) {
                    const dx = coin.x - scaledX;
                    const dy = coin.y - scaledY;
                    if (Math.sqrt(dx * dx + dy * dy) < coin.radius * 2.5) {
                        coin.hasParachute = true;
                        coin.flashTime = 10;
                        parachuteAdded = true;
                        for (let i = 0; i < 3; i++) {
                            particles.push(new Particle(scaledX, scaledY, 'win'));
                        }
                        playSound(220, 'triangle', 0.3);
                    }
                }
            });
            if (!parachuteAdded && coinCount > 0) {
                coins.push(new Coin(scaledX, 50));
                coinCount--;
            } else if (!parachuteAdded) {
                for (let i = 0; i < 3; i++) {
                    particles.push(new Particle(scaledX, scaledY, 'miss'));
                }
            }
        }

        canvas.addEventListener('touchstart', handleInput);
        canvas.addEventListener('click', handleInput);

        function gameLoop() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#1E90FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#8b0000';
            ctx.fillRect(pusher.x * (canvas.width / 800), pusher.y * (canvas.height / 600), pusher.width * (canvas.width / 800), pusher.height * (canvas.height / 600));

            pusher.x += pusher.speed * pusher.direction + (Math.random() - 0.5) * 2;
            if (pusher.x + pusher.width > 800 - 50 || pusher.x < 50) {
                pusher.direction *= -1;
            }

            winZone.x += winZone.speed * winZone.direction;
            if (winZone.x + winZone.width > 800 - 50 || winZone.x < 50) {
                winZone.direction *= -1;
            }

            if (magnetActive) {
                magnetTimer--;
                if (magnetTimer <= 0) magnetActive = false;
                if (Math.random() < 0.1 && particles.length < 100) {
                    const particleX = winZone.x + Math.random() * winZone.width;
                    particles.push(new Particle(particleX, edgeY, 'magnet'));
                }
            }

            coins = coins.filter(coin => !coin.update());
            coins.forEach(coin => coin.draw());

            particles = particles.filter(particle => !particle.update()).slice(-100);
            particles.forEach(particle => particle.draw());

            if (Math.random() < 0.01 && obstacles.length < 3) obstacles.push(new Obstacle());
            obstacles.forEach(obstacle => {
                obstacle.update();
                obstacle.draw();
            });

            ctx.font = `${24 * (canvas.width / 800)}px Arial`;
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(`Score: ${score}`, canvas.width / 2, 40 * (canvas.height / 600));
            ctx.fillText(`Coins Left: ${coinCount}`, canvas.width / 2, 70 * (canvas.height / 600));
            if (magnetActive) {
                const scale = 1 + Math.sin(magnetTimer / 10) * 0.1;
                ctx.font = `${24 * scale * (canvas.width / 800)}px Arial`;
                ctx.fillStyle = `rgba(255, 255, 255, ${magnetTimer / 300})`;
                ctx.fillText('Magnet Active!', canvas.width / 2, 100 * (canvas.height / 600));
            }

            if (winZone.glowTime > 0) {
                ctx.strokeStyle = `rgba(255, 215, 0, ${winZone.glowTime / 20})`;
                ctx.lineWidth = 7 * (canvas.width / 800);
                ctx.beginPath();
                ctx.moveTo(winZone.x * (canvas.width / 800), edgeY * (canvas.height / 600));
                ctx.lineTo((winZone.x + winZone.width) * (canvas.width / 800), edgeY * (canvas.height / 600));
                ctx.stroke();
                winZone.glowTime--;
            }
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 5 * (canvas.width / 800);
            ctx.beginPath();
            ctx.moveTo(winZone.x * (canvas.width / 800), edgeY * (canvas.height / 600));
            ctx.lineTo((winZone.x + winZone.width) * (canvas.width / 800), edgeY * (canvas.height / 600));
            ctx.stroke();

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>